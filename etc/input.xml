<?xml version="1.0" encoding="UTF-8"?>
<commandline xmlns:xi='http://www.w3.org/2001/XInclude'>
   %prog command [subcommand] options
   <command name="*">
      <optgroup name="all commands">
         <option name="verbose" short="v" type="boolean" conflicts="quiet">
            Verbose mode.  Contact the broker for out of band status messages
            about the request while it is being processed.  These messages
            are printed on stderr.  This is the default.
         </option>
         <option name="quiet" short="q" type="boolean" conflicts="verbose">
            Turn off verbose mode.  Do not make a secondary request to
            the broker for out of band status messages.
         </option>
         <option name="debug" short="d" type="boolean" conflicts="">
            Generate debug statements sent to stderr.  Some commands may
            also increase output from the server on stdout.
         </option>
         <option name="httpinfo" short="u" type="boolean" conflicts="">
            Show the URL being accessed and the response code.
            Implied by --debug.
         </option>
         <option name="format" short="f" type="string" conflicts="">
            Specify output format as raw (default) or html.
         </option>
         <option name="noauth" type="boolean" conflicts="usesock">
            Connect to port without authentication (without knc).
         </option>
         <option name="noexec" short="n" type="boolean">
            If the server sends back a command to run, echo it and exit.
         </option>
         <option name="usesock" type="string" conflicts="noauth">
            Connect directly (noauth) to the given unix socket.
         </option>
         <option name="slowstatus" type="boolean" conflicts="quiet">
            Request status messages from the server only after the
            original request completes.  This is only meant to be used
            for aqd development with a broker running with a sqlite database.
         </option>
         <option name="aqport" type="string" conflicts="">
            Server port to connect to
         </option>
         <option name="aqhost" type="string" conflicts="">
            Name of the server to connect to
         </option>
         <option name="aquser" type="string" conflicts="">
            Name of the userid running the server.  Should default correctly,
            only useful for development.
         </option>
      </optgroup>
   </command>

   <command name="status">
      Shows the current server status.
      <transport method="get" path="" />
   </command>

   <command name="flush">
      Force the server to (re)write the plenary templates
      based on the current information in AQDB. This is intended to
      be used when re-creating the server state after a rebuild, or
      when upgrading the broker.

      Requires aqd_admin entitlement.

      Without arguments, no templates are selected for flushing. Use
      either --all to select all templates, or specify which groups
      of templates to flush by combining arguments. For example, "flush
      --hosts --machines" would flush all the host and machine templates
      but would leave all other plenary templates alone.

      The command will return success if all templates selected were
      written without error. The command will return partial success if
      any templates could not be written. The output of the command indicates
      how many templates were successfully written and how many templates
      were selected. For example "flushed 10/10 templates" would indicate
      that 10 templates matched and they were all written out successfully.
      <optgroup name="sections" fields="any">
         <option name="hosts" type="boolean">flush the host templates</option>
         <option name="machines" type="boolean">flush the machine templates</option>
         <option name="personalities" type="boolean">flush the personality templates</option>
         <option name="clusters" type="boolean">flush the cluster templates</option>
         <option name="services" type="boolean">flush the service templates</option>
         <option name="all" type="boolean">flush all templates</option>
      </optgroup>
      <transport method="post" path="flush" />
   </command>

   <command name="ping">
      Simple test that the broker can respond.
      <transport method="get" path="ping" />
   </command>

   <command name="show_active_commands">
      Show any active commands currently running on the broker.

      In this version, the command does not make a database connection
      and relies on in memory knowledge of running commands.  This
      behavior may change in a future version.
      <transport method="get" path="active_commands" />
   </command>

   <command name="show_active_locks">
      Show any active locks currently held by broker commands.

      In this version, the command does not make a database connection
      and relies on in memory knowledge of acquired locks.  This
      behavior may change in a future version.
      <transport method="get" path="active_locks" />
   </command>

   <command name="show_request">
      Show any status messages for the given request.

      The request can be identified by either the request id generated by
      the client when a request is initiated or by the audit id generated
      by the server when a request comes in.
      <optgroup name="show_request_mandatory" mandatory="True" fields="any">
         <option name="requestid" type="string" conflicts="auditid">Client-created Request ID</option>
         <option name="auditid" type="string" conflicts="requestid">Server-created Audit ID</option>
      </optgroup>
      <transport method="get" path="status/requestid/%(requestid)s" />
      <transport method="get" trigger="auditid" path="status/auditid/%(auditid)s" />
   </command>

   <command name="show_host">
      Shows the complete configuration for a given host. If the '--all' option
      is provided, then the command simply outputs a listing of all known hostnames.
      <optgroup name="show_host_Input" mandatory="True" fields="any">
         <option name="hostname" type="string" conflicts="all">Host name</option>
         <option name="all" type="boolean" conflicts="hostname">Select all hosts</option>
      </optgroup>
      <transport trigger="all" method="get" path="host" />
      <transport trigger="hostname" method="get" path="host/%(hostname)s" />
   </command>

   <command name="show_fqdn">
      Shows any information available for the fqdn.  This could be a host,
      a top of rack switch, a chassis, or any other system tracked by
      AQDB.
      <optgroup name="show_fqdn_opts" mandatory="True" fields="any">
         <option name="fqdn" type="string" conflicts="all">full qualified domain name</option>
         <option name="all" type="boolean" conflicts="fqdn">select all systems</option>
      </optgroup>
      <transport trigger="all" method="get" path="system" />
      <transport trigger="fqdn" method="get" path="system/%(fqdn)s" />
   </command>

   <command name="search_hardware">
      Shows any information available for the matching hardware.  These
      could be machines, top of rack switches, chassis, or any other hardware
      tracked by AQDB.

      Note that location searches are exact-only.  That is, if searching
      for a machine in a rack, and the rack is in the requested building,
      the search will not return the machine.
      <optgroup name="search_hardware_opts" mandatory="True" fields="any">
         <option name="model" type="string">model name</option>
         <option name="machine_type" type="string">machine type for the model (blade, virtual_machine, etc.)</option>
         <option name="vendor" type="string">vendor name</option>
         <option name="mac" type="string">mac address of an attached interface</option>
         <option name="pg" type="string">port group of an attached interface</option>
         <option name="serial" type="string">serial number</option>
         <optgroup name="search_hardware_location_opts" fields="any">
	    <option name="organization" type="string">Organization</option>
	    <option name="hub" type="string">Hub</option>
	    <option name="continent" type="string">Continent</option>
	    <option name="country" type="string">Country</option>
	    <option name="city" type="string">City</option>
	    <option name="building" type="string">Building</option>
	    <option name="room" type="string">Room</option>
	    <option name="rack" type="string">Rack</option>
	    <option name="desk" type="string">Desk</option>
         </optgroup>
         <option name="all" type="boolean">list all hardware</option>
      </optgroup>
      <optgroup name="search_system_prefs" mandatory="False">
         <option name="fullinfo" type="boolean">show full information for the matching hardware</option>
      </optgroup>
      <transport method="get" path="find/hardware" />
   </command>

   <command name="search_machine">
      Shows any information available for machine hardware.

      (See search_hardware for a more general hardware search.)

      Note that location searches are exact-only.  That is, if searching
      for a machine in a rack, and the rack is in the requested building,
      the search will not return the machine.
      <optgroup name="search_machine_opts" mandatory="True" fields="any">
         <option name="name" type="string">machine name (exact)</option>
         <option name="cpuname" type="string">cpu name</option>
         <option name="cpuvendor" type="string">cpu vendor</option>
         <option name="cpuspeed" type="string">cpu speed</option>
         <option name="cpucount" type="string">cpu count</option>
         <option name="memory" type="string">memory in MB</option>
         <option name="cluster" type="string">cluster name</option>
         <option name="model" type="string">model name</option>
         <option name="machine_type" type="string">machine type for the model (blade, virtual_machine, etc.)</option>
         <option name="vendor" type="string">vendor name</option>
         <option name="mac" type="string">mac address of an attached interface</option>
         <option name="pg" type="string">port group of an attached interface</option>
         <option name="serial" type="string">serial number</option>
         <option name="share" type="string">nas_disk_share in use by a virtual machine</option>
         <optgroup name="search_machine_location_opts" fields="any">
	    <option name="organization" type="string">Organization</option>
	    <option name="hub" type="string">Hub</option>
	    <option name="continent" type="string">Continent</option>
	    <option name="country" type="string">Country</option>
	    <option name="city" type="string">City</option>
	    <option name="building" type="string">Building</option>
	    <option name="room" type="string">Room</option>
	    <option name="rack" type="string">Rack</option>
	    <option name="desk" type="string">Desk</option>
         </optgroup>
         <option name="all" type="boolean">list all hardware</option>
      </optgroup>
      <optgroup name="search_system_prefs" mandatory="False">
         <option name="fullinfo" type="boolean">show full information for the machine</option>
      </optgroup>
      <transport method="get" path="find/machine" />
   </command>

   <command name="search_system">
      Shows any information available for the matching systems.  These
      could be hosts, top of rack switches, chassis, or any other system
      tracked by AQDB.
      <optgroup name="search_system_opts" mandatory="True" fields="any">
         <option name="fqdn" type="string">fully qualified domain name</option>
         <option name="dnsdomain" type="string">DNS domain</option>
         <option name="shortname" type="string">First segment of the fqdn</option>
         <option name="type" type="string">System type (host, chassis, tor_switch, manager, auxiliary)</option>
         <option name="ip" type="string">IP address</option>
         <option name="networkip" type="string">Network IP address</option>
         <option name="mac" type="string">primary mac address</option>
         <option name="all" type="boolean">list all systems</option>
      </optgroup>
      <optgroup name="search_system_prefs" mandatory="False">
         <option name="fullinfo" type="boolean">show full information for the matching systems</option>
      </optgroup>
      <transport method="get" path="find/system" />
   </command>

   <command name="search_host">
      Shows any information available for the matching hosts.
      <optgroup name="search_host_opts" mandatory="True" fields="any">
         <option name="hostname" type="string">fully qualified domain name</option>
         <option name="machine" type="string">node name</option>
         <option name="dnsdomain" type="string">DNS domain</option>
         <option name="shortname" type="string">First segment of the fqdn</option>
         <option name="domain" type="string">template domain</option>
         <option name="archetype" type="string">archetype (aquilon, windows, aurora)</option>
         <option name="buildstatus" type="string">buildstatus (blind, build, ready)</option>
         <option name="ip" type="string">IP address</option>
         <option name="networkip" type="string">Network IP address</option>
         <option name="mac" type="string">primary mac address</option>
         <option name="personality" type="string">personality</option>
         <option name="osname" type="string">osname</option>
         <option name="osversion" type="string">osversion</option>
         <option name="service" type="string">client of service (single service only)</option>
         <option name="instance" type="string">client of service instance (single instance only)</option>
         <option name="model" type="string">machine model name</option>
         <option name="machine_type" type="string">machine type for the model (blade, virtual_machine, etc.)</option>
         <option name="vendor" type="string">machine vendor name</option>
         <option name="serial" type="string">machine serial number</option>
         <option name="cluster" type="string">cluster name</option>
         <optgroup name="search_hardware_location_opts" fields="any">
	    <option name="organization" type="string">Organization</option>
	    <option name="hub" type="string">Hub</option>
	    <option name="continent" type="string">Continent</option>
	    <option name="country" type="string">Country</option>
	    <option name="city" type="string">City</option>
	    <option name="building" type="string">Building</option>
	    <option name="room" type="string">Room</option>
	    <option name="rack" type="string">Rack</option>
	    <option name="desk" type="string">Desk</option>
         </optgroup>
         <option name="all" type="boolean">list all systems</option>
      </optgroup>
      <optgroup name="search_host_prefs" mandatory="False">
         <option name="fullinfo" type="boolean">show full information for the matching hosts</option>
      </optgroup>
      <transport method="get" path="find/host" />
   </command>

   <command name="search_esx_cluster">
      Shows any information available for the matching ESX clusters.

      There are three sets of parameters: 1 - those that match directly
      against the cluster (name, domain, cluster_building, etc.).  2 -
      those that match against the ESX vmhosts that make up the cluster
      (esx_hostname, vmhost_rack, etc.).  3 - those that match against
      the virtual machines running on the cluster (virtual_machine,
      guest).
      <optgroup name="search_cluster_opts" mandatory="True" fields="any">
         <option name="cluster" type="string">cluster name</option>
         <option name="metacluster" type="string">metacluster name</option>
         <option name="esx_hostname" type="string">fully qualified domain name of a vmhost</option>
         <option name="virtual_machine" type="string">virtual machine label (evm1)</option>
         <option name="guest" type="string">fully qualified host name of a virtual machine</option>
         <option name="domain" type="string">template domain</option>
         <option name="archetype" type="string">archetype (vmhost)</option>
         <option name="personality" type="string">personality</option>
         <option name="service" type="string">client of service (single service only)</option>
         <option name="instance" type="string">client of service instance (single instance only)</option>
         <option name="share" type="string">nas_disk_share in use by an virtual machine on the cluster</option>
         <optgroup name="search_cluster_location_opts" fields="any">
	    <option name="cluster_organization" type="string">Cluster Organization</option>
	    <option name="cluster_hub" type="string">Cluster Hub</option>
	    <option name="cluster_continent" type="string">Cluster Continent</option>
	    <option name="cluster_country" type="string">Cluster Country</option>
	    <option name="cluster_city" type="string">Cluster City</option>
	    <option name="cluster_building" type="string">Cluster Building</option>
	    <option name="cluster_room" type="string">Cluster Room</option>
	    <option name="cluster_rack" type="string">Cluster Rack</option>
	    <option name="cluster_desk" type="string">Cluster Desk</option>
         </optgroup>
         <optgroup name="search_vmhost_location_opts" fields="any">
	    <option name="vmhost_organization" type="string">vmhost Organization</option>
	    <option name="vmhost_hub" type="string">vmhost Hub</option>
	    <option name="vmhost_continent" type="string">vmhost Continent</option>
	    <option name="vmhost_country" type="string">vmhost Country</option>
	    <option name="vmhost_city" type="string">vmhost City</option>
	    <option name="vmhost_building" type="string">vmhost Building</option>
	    <option name="vmhost_room" type="string">vmhost Room</option>
	    <option name="vmhost_rack" type="string">vmhost Rack</option>
	    <option name="vmhost_desk" type="string">vmhost Desk</option>
         </optgroup>
         <option name="all" type="boolean">list all ESX clusters</option>
      </optgroup>
      <optgroup name="search_cluster_prefs" mandatory="False">
         <option name="fullinfo" type="boolean">show full information for the matching clusters</option>
      </optgroup>
      <transport method="get" path="find/cluster/esx" />
   </command>

   <command name="search_observed_mac">
      Search poll_tor_switch results.

      Supported options for --format: csv.

      The 'csv' format contains the following fields, in this order:
      Switch FQDN, port, MAC address, Last Observation Date
      <optgroup name="search_observed_mac_opts" mandatory="True" fields="any">
         <option name="tor_switch" type="string">FQDN of the switch</option>
         <option name="port_number" type="string">Port number on the switch</option>
         <option name="mac" type="string">MAC address to search for</option>
      </optgroup>
      <transport method="get" path="find/observed_mac" />
   </command>

   <command name="search_next">
      Search for the next available number in a series.  If entries are
      found in the database of the prefix followed by a number, the
      numbers are sorted and the highest number plus one is returned.
      If no entries are found, the command returns 1.  If the --pack
      option is given the first free value is returned instead of choosing
      one past the highest.  This will fill in any "holes" in the sequence.

      Use the --number flag to return just that number, otherwise
      return the full name.

      Use the --start option to count from a number other than 1.

      Examples:

      aq search_next --machine evm

      aq search_next --short igrid --dns_domain devin1.ms.com --number

      aq search_next --cluster ddecl

      aq search_next --metacluster namc
      <optgroup name="search_next_type" mandatory="True" fields="any">
         <option name="machine" type="string" conflicts="short cluster metacluster">Machine prefix to check</option>
         <optgroup name="search_next_fqdn" fields="all">
            <option name="short" type="string" conflicts="machine cluster metacluster">FQDN prefix to check</option>
            <option name="dns_domain" type="string">DNS domain for FQDN</option>
         </optgroup>
         <option name="cluster" type="string" conflicts="machine short metacluster">Cluster prefix to check</option>
         <option name="metacluster" type="string" conflicts="machine short cluster">Metacluster prefix to check</option>
      </optgroup>
      <optgroup name="search_system_prefs" mandatory="False">
         <option name="number" type="boolean">show only the next number</option>
         <option name="fullname" type="boolean">show the next available full name (default)</option>
         <option name="pack" type="boolean">Return first free value</option>
         <option name="start" type="string">Start counting at a different number than one</option>
      </optgroup>
      <transport method="get" trigger="short" path="find/next/system" />
      <transport method="get" trigger="machine" path="find/next/machine" />
      <transport method="get" trigger="cluster" path="find/next/cluster" />
      <transport method="get" trigger="metacluster" path="find/next/metacluster" />
   </command>

   <command name="compile">
      Compile anything that is out-of-date within a specified domain or
      only for the specified host.  Only out of date profiles will be
      compiled.
      <optgroup name="compile_input" mandatory="True" fields="any">
         <option name="domain" type="string" conflicts="hostname">Domain name</option>
      <option name="hostname" type="string" conflicts="domain">FQDN</option>
      </optgroup>
      <transport method="post" path="compile"/>
      <transport trigger="hostname" method="post" path="host/%(hostname)s/command/compile" />
   </command>

   <command name="show_domain">
      Shows the configuration for a given domain. With the '--all' option,
      every domain will be listed, with its configuration.
      <optgroup name="show_domain_Input" mandatory="True" fields="any">
         <option name="domain" type="string" conflicts="all">Domain name</option>
         <option name="all" type="boolean" conflicts="hostname">Select all domains</option>
      </optgroup>
      <transport trigger="all" method="get" path="domain" />
      <transport trigger="domain" method="get" path="domain/%(domain)s" />
   </command>

   <command name="show_network">
      Shows the configuration for a network, or for networks selected by location.

      Supported options for --format: raw, csv, proto.

      The 'csv' format contains the following fields, in this order:
      Network name, IP, Netmask, Sysloc, Country code, Side, Type, Comments.
      <optgroup name="show_network_Input" mandatory="True" fields="any">
         <option name="network" type="string" conflicts="">Network name</option>
         <option name="ip" type="string" conflicts="">IP address</option>
         <option name="all" type="boolean" conflicts="">All</option>
         <optgroup name="show_network_options" fields="any">
            <option name="type" type="string">Network type</option>
            <option name="hosts" type="boolean">Hosts</option>
            <option name="discoverable" type="boolean">Discoverable</option>
            <option name="discovered" type="boolean">Discovered</option>
         </optgroup>
         <optgroup name="show_network_location_opts" fields="any">
	    <option name="organization" type="string">Organization</option>
	    <option name="hub" type="string">Hub</option>
	    <option name="continent" type="string">Continent</option>
	    <option name="country" type="string">Country</option>
            <option name="campus" type="string">Campus</option>
	    <option name="city" type="string">City</option>
	    <option name="building" type="string">Building</option>
	    <option name="room" type="string">Room</option>
	    <option name="rack" type="string">Rack</option>
	    <option name="desk" type="string">Desk</option>
         </optgroup>
      </optgroup>
      <transport method="get" path="network" />
   </command>

   <command name="refresh_network">
      Refresh aqdb network information from dsdb.

      Generally this command is called with the --all option but can be
      restricted to a single building for speed.  A dryrun option is
      provided to see what would change.

      Using the incremental option will cause every change to be committed
      to the database individually.  This is recommended for automated
      usage but is off by default for interactive use as it is slower.
      <optgroup name="refresh_network_mandatory" mandatory="True" fields="any">
         <option name="building" type="string" conflicts="all">Building name</option>
         <option name="all" type="boolean" conflicts="building">All locations</option>
      </optgroup>
      <optgroup name="refresh_network_mandatory" mandatory="False">
         <option name="dryrun" type="boolean" conflicts="incremental">Report what will change</option>
         <option name="incremental" type="boolean" conflicts="dryrun">Commit every change as it is decided</option>
      </optgroup>
      <transport method="post" path="command/net_refresh" />
   </command>

   <command name="refresh_windows_hosts">
      Refresh Windows host entries based on information in the data warehouse.

      The data warehouse contains a merge of host/machine/interface data
      from both aqdb and Windows hosts using those interfaces.  This syncs
      up any non-conflicting data.

      The add_windows_host and del_windows_host commands can be used to
      create entries manually.
      <optgroup name="refresh_windows_hosts_optional" mandatory="False">
         <option name="dryrun" type="boolean" conflicts="">Report what will change</option>
      </optgroup>
      <transport method="post" path="command/refresh_windows_hosts" />
   </command>

   <command name="show_hostiplist">
      Shows a list of all hosts.  Can be narrowed by archetype.
      <optgroup name="show_hostiplist_options">
         <option name="archetype" type="string">Archetype name</option>
      </optgroup>
      <transport trigger="archetype" method="get" path="search/hostiplist/archetype/%(archetype)s" />
      <transport method="get" path="search/hostiplist" />
   </command>

   <command name="show_machinemaclist">
      Shows a list of all MAC addresses.
      <transport method="get" path="search/machinemaclist" />
   </command>

   <command name="show_hostmachinelist">
      %prog show hostmachinelist
      Shows a list of all hosts and the machine (aka node) they're associated with.
      <optgroup name="show_hostmachinelist_options">
         <option name="archetype" type="string">Archetype name</option>
      </optgroup>
      <transport trigger="archetype" method="get" path="archetype/%(archetype)s/hostmachinelist" />
      <transport method="get" path="search/hostmachinelist" />
   </command>

   <command name="add_cpu">
      Add a new CPU type to the database.
      <optgroup name="add_cpu_opts" mandatory="True" fields="all">
         <option name="cpu" type="string">CPU type name</option>
         <option name="vendor" type="string">name of the vendor</option>
         <option name="speed" type="string">CPU speed</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="hardware/cpu/%(vendor)s/%(cpu)s/%(speed)s" />
   </command>

   <command name="show_cpu">
      Show the CPU types in the database
      <optgroup name="show_cpu_opts" mandatory="True" fields="any">
         <option name="all" type="boolean">Show all cpu types</option>
         <option name="cpu" type="string">CPU type name</option>
         <option name="vendor" type="string">name of the vendor</option>
         <option name="speed" type="string">CPU speed</option>
      </optgroup>
      <transport method="get" path="find/hardware/cpu" />
   </command>

   <command name="del_cpu">
      Delete a CPU type from the database
      <optgroup name="del_cpu_opts" mandatory="True" fields="all">
         <option name="cpu" type="string">CPU type name</option>
         <option name="vendor" type="string">name of the vendor</option>
         <option name="speed" type="string">CPU speed</option>
      </optgroup>
      <transport method="delete" path="hardware/cpu/%(vendor)s/%(cpu)s/%(speed)s" />
   </command>

   <command name="add_disk">
      Add a new disk to a machine
      <optgroup name="add_disk_opts" mandatory="True" fields="all">
         <option name="machine" type="string">machine ID</option>
         <option name="disk" type="string">device name of the disk (like sda)</option>
         <option name="type" type="string">type of the disk</option>
         <option name="capacity" type="string">capacity of the disk (GB)</option>
      </optgroup>
      <optgroup name="nas_opts" fields="all">
         <option name="share" type="string">share name (an instance of nas_disk_share service)</option>
         <option name="address" type="string">bus address (e.g. 0:0)</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="machine/%(machine)s/disk/%(disk)s" />
   </command>

   <command name="del_disk">
      Delete a disk from a machine.

      If more than one disk matches, they will not be deleted.  Use the
      --all flag to override this and delete all matching disks.
      <optgroup name="del_disk_opts" mandatory="True" fields="all">
         <option name="machine" type="string">machine ID</option>
      </optgroup>
      <optgroup name="del_disk_optional_opts" mandatory="False">
         <option name="disk" type="string">device name of the disk (like sda)</option>
         <option name="type" type="string">type of the disk</option>
         <option name="capacity" type="string">capacity of the disk</option>
         <option name="all" type="boolean">remove any matching disks</option>
      </optgroup>
      <transport trigger="disk" method="delete" path="machine/%(machine)s/disk/%(disk)s" />
      <transport method="post" path="hardware/disk/%(machine)s/command/del" />
   </command>

   <command name="add_host">
      Add a new host to the database.  Requires a machine with a bootable
      interface and a valid IP address.

      The IP address can be derived based on aqdb availabililty using:
      --ipfromip:     choose a free IP address in the subnet of the given ip
      --ipfromsystem: choose based on the subnet in use by the given system
      --autoip:       check discovery tables (filled in by aq poll)

      Two algorithms are available for deriving the IP address.
      lowest:         Use lowest available IP in the subnet.
      max:            Find the highest IP in use and add one.
      The default is lowest.
      <optgroup name="add_host_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Fully qualified Host name</option>
         <option name="machine" type="string">Machine (Node) name</option>
         <option name="archetype" type="string">Archetype name</option>
         <option name="domain" type="string">Aquilon (not DNS) domain</option>
         <optgroup name="add_host_ip_opts" mandatory="True" fields="any">
            <option name="ip" type="string" conflicts="ipfromip ipfromsystem autoip">IP address</option>
            <option name="ipfromip" type="string" conflicts="ip ipfromsystem autoip">choose IP address in subnet</option>
            <option name="ipfromsystem" type="string" conflicts="ip ipfromip autoip">choose IP address in subnet of system</option>
            <option name="autoip" type="boolean" conflicts="ip ipfromip ipfromsystem">choose IP address based on mac/switch</option>
         </optgroup>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="osname" type="string">Operating system (e.g. linux)</option>
         <option name="osversion" type="string">Operating system version (e.g. 5.0-x86_64)</option>
         <option name="buildstatus" type="string">Build Status: defaults to build.  'blind' and 'ready' also valid.</option>
         <option name="personality" type="string">Personality name: defaults to 'inventory' for aquilon and 'generic' otherwise.</option>
         <option name="ipalgorithm" type="string">Algorithm for automatically choosing an IP.  Either lowest or max.</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="host/%(hostname)s" />
   </command>

   <command name="add_aquilon_host">
      Add a new host to the database with archetype aquilon.  Requires a
      machine with a bootable interface and a valid IP address.

      The IP address can be derived based on aqdb availabililty using:
      --ipfromip:     choose a free IP address in the subnet of the given ip
      --ipfromsystem: choose based on the subnet in use by the given system
      --autoip:       check discovery tables (filled in by aq poll)

      Two algorithms are available for deriving the IP address.
      lowest:         Use lowest available IP in the subnet.
      max:            Find the highest IP in use and add one.
      The default is lowest.
      <optgroup name="add_aquilon_host_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Fully qualified Host name</option>
         <option name="machine" type="string">Machine (Node) name</option>
         <option name="domain" type="string">Aquilon (not DNS) domain</option>
         <optgroup name="add_host_ip_opts" mandatory="True" fields="any">
            <option name="ip" type="string" conflicts="ipfromip ipfromsystem autoip">IP address</option>
            <option name="ipfromip" type="string" conflicts="ip ipfromsystem autoip">choose IP address in subnet</option>
            <option name="ipfromsystem" type="string" conflicts="ip ipfromip autoip">choose IP address in subnet of system</option>
            <option name="autoip" type="boolean" conflicts="ip ipfromip ipfromsystem">choose IP address based on mac/switch</option>
         </optgroup>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="osname" type="string">Operating system (e.g. linux)</option>
         <option name="osversion" type="string">Operating system version (e.g. 5.0-x86_64)</option>
         <option name="buildstatus" type="string">Build Status: defaults to build.  'blind' and 'ready' also valid.</option>
         <option name="comments" type="string">Comments</option>
         <option name="personality" type="string">Personality name.  Defaults to 'inventory'.</option>
         <option name="ipalgorithm" type="string">Algorithm for automatically choosing an IP.  Either lowest or max.</option>
      </optgroup>
      <transport method="put" path="aquilon_host/%(hostname)s" />
   </command>

   <command name="add_windows_host">
      Add a new host to the database with archetype windows.  Requires a
      machine with a bootable interface and a valid IP address.

      The IP address can be derived based on aqdb availabililty using:
      --ipfromip:     choose a free IP address in the subnet of the given ip
      --ipfromsystem: choose based on the subnet in use by the given system
      --autoip:       check discovery tables (filled in by aq poll)

      Two algorithms are available for deriving the IP address.
      lowest:         Use lowest available IP in the subnet.
      max:            Find the highest IP in use and add one.
      The default is lowest.

      Currently operating system name/version is windows/generic for all windows
      machines since they are the only versions in the database.
      <optgroup name="add_windows_host_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Fully qualified Host name</option>
         <option name="machine" type="string">Machine (Node) name</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="buildstatus" type="string">Build Status: defaults to build.  'blind' and 'ready' also valid.</option>
         <option name="personality" type="string">Personality name.  See `aq show personality --archetype windows`.  Currently defaults to 'generic'.</option>
         <option name="comments" type="string">Comments</option>
         <option name="ipalgorithm" type="string">Algorithm for automatically choosing an IP.  Either lowest or max.</option>
         <optgroup name="add_host_ip_opts" mandatory="False" fields="any">
            <option name="ip" type="string" conflicts="ipfromip ipfromsystem autoip">IP address</option>
            <option name="ipfromip" type="string" conflicts="ip ipfromsystem autoip">choose IP address in subnet</option>
            <option name="ipfromsystem" type="string" conflicts="ip ipfromip autoip">choose IP address in subnet of system</option>
            <option name="autoip" type="boolean" conflicts="ip ipfromip ipfromsystem">choose IP address based on mac/switch</option>
         </optgroup>
      </optgroup>
      <transport method="put" path="windows_host/%(hostname)s" />
   </command>

   <command name="add_aurora_host">
      Add a placeholder host to the database to represent an aurora host.
      <optgroup name="add_host_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Fully qualified Host name</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="osname" type="string">Operating system: defaults to linux, no solaris (yet)</option>
         <option name="osversion" type="string">Operating system version (e.g. 5.0-x86_64. Defaults to 'generic')</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="aurora_host/%(hostname)s" />
   </command>

   <command name="add_auxiliary">
      Add an auxiliary entry for a host to the database.  Requires a
      machine with a non-bootable public interface (generally eth1) and a
      valid IP address.

      The host can be identified by either --machine or --hostname.  The
      new/auxiliary name must be given with --auxiliary.

      If both --interface and --mac are given and there is no such
      interface, it will be created.

      For a host like igrid123.subdomain.ms.com, an example auxiliary name
      for the eth1 interface is igrid123-e1.subdomain.ms.com.

      After running this, run reconfigure on the primary host (in the
      example above, igrid123.subdomain.ms.com).

      The IP address can be derived based on aqdb availabililty using:
      --ipfromip:     choose a free IP address in the subnet of the given ip
      --ipfromsystem: choose based on the subnet in use by the given system
      --autoip:       check discovery tables (filled in by aq poll)

      Two algorithms are available for deriving the IP address.
      lowest:         Use lowest available IP in the subnet.
      max:            Find the highest IP in use and add one.
      The default is lowest.
      <optgroup name="add_aux_opts" mandatory="True" fields="all">
         <optgroup name="add_aux_identifier" mandatory="True" fields="any">
            <option name="hostname" type="string" conflicts="machine">Fully qualified Host name</option>
            <option name="machine" type="string" conflicts="hostname">Machine (Node) name</option>
	 </optgroup>
         <option name="auxiliary" type="string">Fully qualified name for the auxiliary interface</option>
	 <optgroup name="add_aux_ip_opts" mandatory="True" fields="any">
            <option name="ip" type="string" conflicts="ipfromip ipfromsystem autoip">IP address</option>
            <option name="ipfromip" type="string" conflicts="ip ipfromsystem autoip">choose IP address in subnet</option>
            <option name="ipfromsystem" type="string" conflicts="ip ipfromip autoip">choose IP address in subnet of system</option>
	    <option name="autoip" type="boolean" conflicts="ip ipfromip ipfromsystem">choose IP address based on mac/switch</option>
	 </optgroup>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="interface" type="string">Specify the non-bootable public interface to use, if there is more than one.</option>
         <option name="mac" type="string">Specify the non-bootable public interface to use, if there is more than one.</option>
         <option name="ipalgorithm" type="string">Algorithm for automatically choosing an IP.  Either lowest or max.</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="auxiliary/%(auxiliary)s" />
   </command>

   <command name="show_auxiliary">
      Shows the information for auxiliary systems (like
      igrid123-e1.subdomain.ms.com)
      <optgroup name="show_auxiliary_opts" mandatory="True" fields="any">
         <option name="auxiliary" type="string" conflicts="all">Auxiliary name</option>
         <option name="all" type="boolean" conflicts="auxiliary">Select all auxiliaries</option>
      </optgroup>
      <transport trigger="all" method="get" path="auxiliary" />
      <transport trigger="auxiliary" method="get" path="auxiliary/%(auxiliary)s" />
   </command>

   <command name="del_auxiliary">
      Delete an auxiliary entry for a host from the database.

      For a host like igrid123.subdomain.ms.com, an example auxiliary name
      for the eth1 interface is igrid123-e1.subdomain.ms.com.

      After running this, run reconfigure on the primary host (in the
      example above, igrid123.subdomain.ms.com).
      <optgroup name="add_aux_opts" mandatory="True" fields="all">
         <option name="auxiliary" type="string">Fully qualified name for the auxiliary interface</option>
      </optgroup>
      <transport method="delete" path="auxiliary/%(auxiliary)s" />
   </command>

   <command name="add_manager">
      Add a manager entry for a host to the database.  Requires a
      host with a management interface and a valid IP address.

      The manager name can be overridden with --manager.  The default
      is to add an 'r' to the first component of the hostname.  For a
      host like igrid123.subdomain.ms.com, the default manager name
      is igrid123r.subdomain.ms.com.

      If both --interface and --mac are given and there is no such
      interface, it will be created.

      After running this, run reconfigure on the primary host (in the
      example above, igrid123.subdomain.ms.com).

      The IP address can be derived based on aqdb availabililty using:
      --ipfromip:     choose a free IP address in the subnet of the given ip
      --ipfromsystem: choose based on the subnet in use by the given system
      --autoip:       check discovery tables (filled in by aq poll)

      Two algorithms are available for deriving the IP address.
      lowest:         Use lowest available IP in the subnet.
      max:            Find the highest IP in use and add one.
      The default is lowest.
      <optgroup name="add_manager_opts" mandatory="True" fields="all">
         <option name="hostname" type="string" conflicts="machine">Fully qualified Host name</option>
	 <optgroup name="add_manager_ip_opts" mandatory="True" fields="any">
            <option name="ip" type="string" conflicts="ipfromip ipfromsystem autoip">IP address</option>
            <option name="ipfromip" type="string" conflicts="ip ipfromsystem autoip">choose IP address in subnet</option>
            <option name="ipfromsystem" type="string" conflicts="ip ipfromip autoip">choose IP address in subnet of system</option>
	    <option name="autoip" type="boolean" conflicts="ip ipfromip ipfromsystem">choose IP address based on mac/switch</option>
	 </optgroup>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="manager" type="string">Fully qualified name for the manager interface</option>
         <option name="interface" type="string">Specify the management interface to use, if there is more than one.</option>
         <option name="mac" type="string">Specify the management interface to use, if there is more than one.</option>
         <option name="ipalgorithm" type="string">Algorithm for automatically choosing an IP.  Either lowest or max.</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport trigger="manager" method="put" path="manager/%(manager)s" />
      <transport method="post" path="host/%(hostname)s/command/add_manager" />
   </command>

   <command name="show_manager">
      Shows the information for manager systems (like
      igrid123r.subdomain.ms.com)

      The --missing option will list aq commands to create entries for
      any hosts that have management interfaces but do not have managers.

      These commands need to be run separately in order to create the
      necessary entries.
      <optgroup name="show_manager_opts" mandatory="True" fields="any">
         <option name="manager" type="string" conflicts="all missing">Manger name</option>
         <option name="all" type="boolean" conflicts="manager missing">Select all managers</option>
         <option name="missing" type="boolean" conflicts="manager all">Generate commands to create missing managers</option>
      </optgroup>
      <transport trigger="all" method="get" path="manager" />
      <transport trigger="manager" method="get" path="manager/%(manager)s" />
      <transport trigger="missing" method="get" path="find/missing_managers" />
   </command>

   <command name="del_manager">
      Delete a manager entry for a host from the database.

      For a host like igrid123.subdomain.ms.com, the manager name
      is igrid123r.subdomain.ms.com.

      After running this, run reconfigure on the primary host (in the
      example above, igrid123.subdomain.ms.com).
      <optgroup name="del_manager_opts" mandatory="True" fields="all">
         <option name="manager" type="string">Fully qualified name for the manager interface</option>
      </optgroup>
      <transport method="delete" path="manager/%(manager)s" />
   </command>

   <command name="add_model">
      Add a new model
      <optgroup name="add_model_opts" mandatory="True" fields="all">
         <option name="name" type="string">Name of the new model</option>
         <option name="vendor" type="string">Vendor name</option>
         <option name="type" type="string">Machine type name</option>
      </optgroup>
      <optgroup name="default_config_opts" mandatory="False" fields="all">
         <option name="cputype" type="string">CPU type</option>
         <option name="cpunum" type="string">CPU count</option>
         <option name="mem" type="string">amount of installed memory (MB)</option>
         <option name="disktype" type="string">installed disk type (generally 'local', use 'nas' for virtual disks on NAS)</option>
         <option name="diskcontroller" type="string">controller type (sata, scsi, etc.)</option>
         <option name="disksize" type="string">installed disk capacity (GB)</option>
         <option name="nics" type="string">number of NIC interfaces</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="hardware/model/%(vendor)s/%(name)s" />
   </command>

   <command name="show_model">
      Show a model
      <optgroup name="show_model_opts" mandatory="True" fields="any">
         <option name="name" type="string">Name of the model</option>
         <option name="vendor" type="string">Vendor name</option>
         <option name="type" type="string">Machine type name</option>
         <option name="all" type="boolean">Show all models</option>
      </optgroup>
      <transport method="get" path="find/hardware/model" />
   </command>

   <command name="update_model">
      Update a model, optionally updating all existing hardware of that model.
      The model must be specified by name and vendor.
      If updating the CPU, usually cpuname will be enough to specify a CPU
      uniquely but vendor and speed can be given as well if needed.
      <optgroup name="update_model_specifier" mandatory="True" fields="all">
         <option name="name" type="string">Name of the model to update</option>
         <option name="vendor" type="string">Vendor name</option>
      </optgroup>
      <optgroup name="update_model_values" mandatory="False">
         <option name="newname" type="string">Change model name</option>
         <option name="newvendor" type="string">Change model vendor</option>
         <option name="machine_type" type="string">Machine type name</option>
         <option name="cpuname" type="string">CPU name</option>
         <option name="cpuvendor" type="string">CPU vendor</option>
         <option name="cpuspeed" type="string">CPU speed</option>
         <option name="cpunum" type="string">CPU count</option>
         <option name="mem" type="string">amount of installed memory (MB)</option>
         <option name="disktype" type="string">installed disk type (generally 'local', use 'nas' for virtual disks on NAS)</option>
         <option name="diskcontroller" type="string">controller type (sata, scsi, etc.)</option>
         <option name="disksize" type="string">installed disk capacity (GB)</option>
         <option name="nics" type="string">number of NIC interfaces</option>
         <option name="comments" type="string">Comments</option>
         <option name="leave_existing" type="boolean">Do not update machines using the old defaults to the new values</option>
      </optgroup>
      <transport method="post" path="hardware/model/%(vendor)s/%(name)s" />
   </command>

   <command name="del_model">
      Decomission model
      <optgroup name="del_model_opts" mandatory="True" fields="all">
         <option name="name" type="string">Name of the model</option>
         <option name="vendor" type="string">Vendor name</option>
      </optgroup>
      <transport method="delete" path="hardware/model/%(vendor)s/%(name)s" />
   </command>

   <command name="add_interface">
      Add a new network interface to the database.

      If adding an interface to virtual hardware, the --automac option
      can be used to automatically generate a MAC address based on
      the cluster vendor.

      To give an IP address to a host, provide it when using add_host.

      For chassis and tor_switches, the IP address is provided with this
      command.

      The IP address can be derived based on aqdb availabililty using:
      --ipfromip:     choose a free IP address in the subnet of the given ip
      --ipfromsystem: choose based on the subnet in use by the given system
      --autoip:       check discovery tables (filled in by aq poll)

      Two algorithms are available for deriving the IP address.
      lowest:         Use lowest available IP in the subnet.
      max:            Find the highest IP in use and add one.
      The default is lowest.
      <optgroup name="add_interface_opts" mandatory="True" fields="all">
         <option name="interface" type="string">Interface name</option>
      </optgroup>
      <optgroup name="add_interface_mac" mandatory="False">
         <option name="mac" type="string" conflicts="automac">MAC address</option>
         <option name="automac" type="boolean" conflicts="mac">Automatically generate MAC for virtual hardware</option>
      </optgroup>
      <optgroup name="add_interface_hw" mandatory="True" fields="any">
         <option name="machine" type="string" conflicts="hostname chassis tor_switch ip ipfromip ipfromsystem autoip">Machine (node) name</option>
         <option name="hostname" type="string" conflicts="machine chassis tor_switch ip ipfromip ipfromsystem autoip">Hostname</option>
         <option name="chassis" type="string" conflicts="machine hostname tor_switch">Chassis name</option>
         <option name="tor_switch" type="string" conflicts="machine hostname chassis">TOR Switch name</option>
      </optgroup>
      <optgroup name="add_interface_optional" mandatory="False" fields="none">
         <option name="comments" type="string">Comments</option>
         <option name="ip" type="string" conflicts="hostname ipfromip ipfromsystem autoip">IP address</option>
         <option name="ipfromip" type="string" conflicts="hostname ip ipfromsystem autoip">choose IP address in subnet</option>
         <option name="ipfromsystem" type="string" conflicts="hostname ip ipfromip autoip">choose IP address in subnet of system</option>
         <option name="autoip" type="boolean" conflicts="hostname ip ipfromip ipfromsystem">choose IP address based on mac/switch</option>
         <option name="ipalgorithm" type="string">Algorithm for automatically choosing an IP.  Either lowest or max.</option>
         <option name="pg" type="string" conflicts="autopg">portgroup</option>
         <option name="autopg" type="boolean" conflicts="pg">choose portgroup based on switch</option>
      </optgroup>
      <transport trigger="machine" method="put" path="machine/%(machine)s/interface/%(interface)s" />
      <transport trigger="hostname" method="put" path="host/%(hostname)s/interface/%(interface)s" />
      <transport trigger="chassis" method="put" path="chassis/%(chassis)s/interface/%(interface)s" />
      <transport trigger="tor_switch" method="put" path="tor_switch/%(tor_switch)s/interface/%(interface)s" />
   </command>

   <command name="add_network">
      Define a new network.

      Specify both a name for the network and its ip and mask.  For mask,
      use 1 for a /32, 2 for a /31, 4 for a /30, 8 for a /29, 16 for a /28,
      32 for a /27, 64 for a /26, 128 for a /25, etc.
      <optgroup name="add_network_mandatory" mandatory="True" fields="all">
         <option name="network" type="string">Network name</option>
         <option name="ip" type="string">Network IP address</option>
         <option name="mask" type="string">Network IP mask</option>
         <optgroup name="update_network_location_opts" mandatory="True" fields="any">
            <option name="organization" type="string">Organization</option>
            <option name="hub" type="string">Hub</option>
            <option name="continent" type="string">Continent</option>
            <option name="country" type="string">Country</option>
            <option name="campus" type="string">Campus</option>
            <option name="city" type="string">City</option>
            <option name="building" type="string">Building</option>
            <option name="room" type="string">Room</option>
            <option name="rack" type="string">Rack</option>
            <option name="desk" type="string">Desk</option>
         </optgroup>
      </optgroup>

      <optgroup name="add_network_modifiers" mandatory="False" fields="any">
         <option name="discoverable" type="string">Set network(s) updateable</option>
         <option name="discovered" type="string">Set network(s) updated</option>
         <option name="type" type="string">Network type, defaults to 'unknown'</option>
         <option name="side" type="string">Network side, defaults to 'a'</option>
      </optgroup>
      <transport method="put" path="network/%(ip)s" />
   </command>

   <command name="del_network">
      Remove a network definition.

      Specify the network by its IP.
      <optgroup name="del_network_mandatory" mandatory="True" fields="all">
         <option name="ip" type="string">Network IP address</option>
      </optgroup>
      <transport method="delete" path="network/%(ip)s" />
   </command>

   <command name="update_network">
     Update information about the specified network or networks.

     Update the network either by name or ip of the network, or in bulk with location,
     and/or network type.
     <optgroup name="update_network_opts" mandatory="True" fields="any">
	<option name="network" type="string" conflicts="ip update_network_location_opts">Network name</option>
	<option name="ip" type="string" conflicts="network update_network_location_opts">Network name</option>
	<option name="type" type="string" conflicts="ip network">Network type</option>
	<optgroup name="update_network_location_opts" fields="any">
            <option name="organization" type="string">Organization</option>
	    <option name="hub" type="string">Hub</option>
	    <option name="continent" type="string">Continent</option>
	    <option name="country" type="string">Country</option>
	    <option name="campus" type="string">Campus</option>
	    <option name="city" type="string">City</option>
	    <option name="building" type="string">Building</option>
	    <option name="room" type="string">Room</option>
	    <option name="rack" type="string">Rack</option>
	    <option name="desk" type="string">Desk</option>
	</optgroup>
     </optgroup>
     <optgroup name="update_network_modifiers" mandatory="True" fields="any">
	<option name="discoverable" type="string" conflicts="">Set network(s) updateable</option>
	<option name="discovered" type="string" conflicts="">Set network(s) updated</option>
    </optgroup>
     <transport method="post" path="network" />
   </command>

   <command name="update_interface">
      Update information about the named interface (IP, MAC, or comments).

      To rename the interface, add the new interface and delete the old.
      If the boot flag is given, the interface will be marked bootable,
      and any other interface attached to the machine will have the bootable
      flag set to false.

      For this change to take affect at the host level, run aq reconfigure.
      <optgroup name="update_interface_opts" mandatory="True" fields="all">
         <option name="interface" type="string">Interface name</option>
      </optgroup>
      <optgroup name="update_interface_hw_opts" mandatory="True" fields="any">
         <option name="machine" type="string" conflicts="hostname">Machine name</option>
         <option name="hostname" type="string" conflicts="machine">Host name</option>
      </optgroup>
      <optgroup name="update_interface_optional" mandatory="False" fields="none">
         <option name="mac" type="string">MAC address</option>
         <option name="ip" type="string">IP address</option>
         <option name="boot" type="boolean">Mark the interface as bootable</option>
         <option name="pg" type="string" conflicts="autopg">portgroup, or an empty string to clear</option>
         <option name="autopg" type="boolean" conflicts="pg">choose portgroup based on switch</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport trigger="machine" method="post" path="machine/%(machine)s/interface/%(interface)s" />
      <transport trigger="hostname" method="post" path="host/%(hostname)s/interface/%(interface)s" />
   </command>

   <command name="del_interface">
      Delete a network interface from the database.

      The interface can be specified either by its MAC address or as a
      machine/interface name pair. If a machine has just a single interface
      then just specifying the machine name is enough.

      Note that you can not select an interface by IP address since the object
      that owns the IP address would have to be deleted before deleting the
      interface anyway.
      <optgroup name="del_interface_opts" mandatory="True" fields="any">
         <option name="interface" type="string">Interface name</option>
         <option name="machine" type="string">Machine name</option>
         <option name="mac" type="string">MAC address</option>
      </optgroup>
      <transport method="post" path="interface/command/del" />
   </command>

   <command name="add_service">
      Add a new service. If --instance is also specified, then also
      create a named instance for this service at the same time. Default templates
      describing the service will be created so that any service instances can be
      immediately used (bound and configured) by clients.
      <optgroup name="add_service_opts" mandatory="True" fields="all">
         <option name="service" type="string" mandatory="True">service name</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="comments" type="string">Comments</option>
         <option name="instance" type="string">Instance</option>
      </optgroup>
      <transport method="put" path="service/%(service)s" />
      <transport trigger="instance" method="put" path="service/%(service)s/instance/%(instance)s" />
   </command>

   <command name="show_service">
      Show the configuration of a service. All instances of the service will
      be listed, the number of clients bound to that service and any service mappings.
      If --all is specified, then the configuration of all services will be shown.
      <optgroup name="show_service_opts" mandatory="True" fields="any">
         <option name="service" type="string">Service name</option>
         <option name="server" type="string" conflict="client">Server hostname</option>
	 <option name="client" type="string" conflicts="server">Client hostname</option>
	 <option name="all" type="boolean" conflicts="service">Select all services</option>
      </optgroup>
      <optgroup name="show_service_optional_opts">
	 <option name="instance" type="string">Service Instance</option>
      </optgroup>
      <transport trigger="service" method="get" path="service/%(service)s"/>
      <transport method="get" path="service" />
   </command>

   <command name="show_nas_disk_share">
      Show information for instances of the nas_disk_share service.
      <optgroup name="show_share_opts" mandatory="True" fields="any">
         <option name="share" type="string" conflicts="all">Share name</option>
         <option name="all" type="boolean" conflicts="share">Select all shares</option>
      </optgroup>
      <transport trigger="share" method="get" path="nas_disk_share/%(share)s"/>
      <transport method="get" path="nas_disk_share" />
   </command>

   <command name="update_service">
      Update the maximum client count for a service or service instance.

      The maximum client count for a service instance will default to
      the value set for the service.  The maximum client count for a
      service defaults to unlimited.
      <optgroup name="update_service_opts" mandatory="True" fields="all">
         <option name="service" type="string" mandatory="True">service name</option>
         <optgroup name="update_service_count" mandatory="True" fields="any">
            <option name="max_clients" type="string" conflicts="default">Maximum number of client bindings for an instance</option>
            <option name="default" type="boolean" conflicts="max_clients">Restore default setting</option>
         </optgroup>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="instance" type="string">Instance name</option>
      </optgroup>
      <transport method="post" path="service/%(service)s" />
      <transport trigger="instance" method="post" path="service/%(service)s/instance/%(instance)s" />
   </command>

   <command name="del_service">
      Delete a service. The command will fail if any servers or clients are marked
      as being bound to any of the instances of the service.
      <optgroup name="del_service_opts" mandatory="True" fields="all">
         <option name="service" type="string" mandatory="True">service name</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="instance" type="string">instance name</option>
      </optgroup>
      <transport method="delete" path="service/%(service)s" />
      <transport trigger="instance" method="delete" path="service/%(service)s/instance/%(instance)s" />
   </command>

   <command name="bind_client">
      Bind a service to a client.  If no instance is given and a relevant
      service map has been defined, an instance will be picked automatically.
      If the client already has the service bound, this will fail: use rebind
      client instead.
      <optgroup name="bind_client_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Host name</option>
         <option name="service" type="string">Service name</option>
      </optgroup>
      <optgroup name="bind_client_optional_opts">
         <option name="instance" type="string">Instance name</option>
      </optgroup>
      <transport method="post" path="host/%(hostname)s/client_of_service/%(service)s/bind" />
   </command>

   <command name="rebind_client">
      Bind a service to a client.  If no instance is given and a relevant
      service map has been defined, an instance will be picked automatically.
      If the client already has the service bound, this will override the old value.
      <optgroup name="rebind_client_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Host name</option>
         <option name="service" type="string">Service name</option>
      </optgroup>
      <optgroup name="rebind_client_optional_opts">
         <option name="instance" type="string">Instance name</option>
      </optgroup>
      <transport method="post" path="host/%(hostname)s/client_of_service/%(service)s/rebind" />
   </command>

   <command name="unbind_client">
      Unbind a service from a client.
      <optgroup name="unbind_service_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Host name</option>
         <option name="service" type="string">Service name</option>
      </optgroup>
      <transport method="delete" path="host/%(hostname)s/client_of_service/%(service)s" />
   </command>

   <command name="bind_server">
      Bind a server as a provider of the service instance.
      If the server is already bound as a provider of the service for a
      different instance, this fails.
      <optgroup name="bind_client_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Server name</option>
         <option name="service" type="string">Service name</option>
         <option name="instance" type="string">Instance name</option>
      </optgroup>
      <transport method="post" path="host/%(hostname)s/server_of_service/%(service)s/bind" />
   </command>

   <command name="unbind_server">
      Unbind a server as a provider of the service (instance).
      <optgroup name="unbind_server_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Host name</option>
         <option name="service" type="string">Service name</option>
      </optgroup>
      <optgroup name="unbind_server_optional_opts" mandatory="True" fields="any">
         <option name="instance" type="string">Instance name</option>
         <option name="all" type="boolean">Remove server from all instances of this service</option>
      </optgroup>
      <transport method="delete" path="host/%(hostname)s/server_of_service/%(service)s" />
      <transport trigger="instance" method="delete" path="host/%(hostname)s/server_of_service/%(service)s/instance/%(instance)s" />
   </command>

   <command name="add_required_service">
      Add a required service for an archetype or for only a particular
      personality in the archetype.  Once a service is required, then
      any time a host of that archetype or personality is built, it
      will cause an implicit bind_server to occur for any unbound
      required services.  If an instance cannot be automatically bound,
      then hosts will fail to build, therefore you should ensure that
      any required services have appropriate service mappings to
      declare which instances to use by default.
      <optgroup name="add_required_service_opts" mandatory="True" fields="all">
         <option name="service" type="string" mandatory="True">service name</option>
         <option name="archetype" type="string" mandatory="True">archetype name</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="personality" type="string">personality name</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="service/%(service)s/required_for/archetype/%(archetype)s" />
      <transport trigger="personality" method="put" path="service/%(service)s/required_for/personality/%(archetype)s/%(personality)s" />
   </command>

   <command name="show_archetype">
      Show information about an archetype, including required services.
      <optgroup name="show_archetype_opts" mandatory="True" fields="any">
         <option name="archetype" type="string">archetype name</option>
         <option name="all" type="boolean" conflicts="archetype">Select all services</option>
      </optgroup>
      <transport trigger="archetype" method="get" path="archetype/%(archetype)s" />
      <transport method="get" path="archetype" />
   </command>

   <command name="del_required_service">
      Delete a service from the list of required services for an
      archetype or personality.  Hosts which are already bound to a
      service because it used to be required will be unmodified. If
      you wish to unbind those clients, you must do so manually.
      <optgroup name="del_required_service_opts" mandatory="True" fields="all">
         <option name="service" type="string" mandatory="True">service name</option>
         <option name="archetype" type="string" mandatory="True">archetype name</option>
      </optgroup>
      <optgroup name="del_required_service_optional">
         <option name="personality" type="string" mandatory="True">personality name</option>
      </optgroup>
      <transport method="delete" path="service/%(service)s/required_for/archetype/%(archetype)s" />
      <transport trigger="personality" method="delete" path="service/%(service)s/required_for/personality/%(archetype)s/%(personality)s" />
   </command>

   <command name="map_service">
      Map a service instance to a location. This declares that the specified service
      instance is default within a specific location, and will be a candidate for
      automatic selection during any bind_server (or rebuilds that invoke bind_server)
      commands.
      <optgroup name="map_service_opts" mandatory="True" fields="all">
         <option name="service" type="string" mandatory="True">service name</option>
         <option name="instance" type="string" mandatory="True">instance name</option>
      </optgroup>
      <optgroup name="map_service_personality_opts" fields="all">
         <option name="archetype" type="string">archetype name</option>
         <option name="personality" type="string">personality name</option>
      </optgroup>
      <optgroup name="map_service_location_opts" mandatory="True" fields="any">
        <option name="organization" type="string">Organization</option>
        <option name="hub" type="string">Hub</option>
        <option name="continent" type="string">Continent</option>
        <option name="country" type="string">Country</option>
        <option name="campus" type="string">Campus</option>
        <option name="city" type="string">City</option>
        <option name="building" type="string">Building</option>
        <option name="room" type="string">Room</option>
        <option name="rack" type="string">Rack</option>
        <option name="desk" type="string">Desk</option>
      </optgroup>
      <transport method="post" path="service/%(service)s/instance/%(instance)s/command/map" />
   </command>

   <command name="show_map">
      Show any relevant mappings for the given service, instance, or location.
      <optgroup name="show_map_opts" mandatory="True" fields="any">
         <option name="service" type="string">service name</option>
         <option name="instance" type="string">instance name</option>
         <option name="archetype" type="string">archetype name</option>
         <option name="personality" type="string">personality name</option>
         <optgroup name="show_map_location_opts" fields="any">
            <option name="organization" type="string">Organization</option>
            <option name="hub" type="string">Hub</option>
            <option name="continent" type="string">Continent</option>
            <option name="country" type="string">Country</option>
            <option name="campus" type="string">Campus</option>
            <option name="city" type="string">City</option>
            <option name="building" type="string">Building</option>
            <option name="room" type="string">Room</option>
            <option name="rack" type="string">Rack</option>
            <option name="desk" type="string">Desk</option>
         </optgroup>
         <option name="all" type="boolean">show all maps</option>
      </optgroup>
      <transport method="get" path="show/map" />
   </command>

   <command name="unmap_service">
      Remove the map from a service instance to a location. Existing bindings of
      clients will remain unmodified.
      <optgroup name="unmap_service_opts" mandatory="True" fields="all">
         <option name="service" type="string" mandatory="True">service name</option>
         <option name="instance" type="string" mandatory="True">instance name</option>
      </optgroup>
      <optgroup name="unmap_service_personality_opts" mandatory="False" fields="all">
         <option name="archetype" type="string">archetype name</option>
         <option name="personality" type="string">personality name</option>
      </optgroup>
      <optgroup name="unmap_service_location_opts" mandatory="True" fields="any">
         <option name="organization" type="string">Organization</option>
         <option name="hub" type="string">Hub</option>
         <option name="continent" type="string">Continent</option>
         <option name="country" type="string">Country</option>
         <option name="campus" type="string">Campus</option>
         <option name="city" type="string">City</option>
         <option name="building" type="string">Building</option>
         <option name="room" type="string">Room</option>
         <option name="rack" type="string">Rack</option>
         <option name="desk" type="string">Desk</option>
      </optgroup>
      <transport method="post" path="service/%(service)s/instance/%(instance)s/command/unmap" />
   </command>

   <command name="del_host">
      Delete a host. This will fail if the host is being used to provide
      any services. Once the host has been deleted, all configuration data will
      be discarded and the host will be unable to rebuild.
      <optgroup name="del_host_opts" mandatory="True" fields="all">
         <option name="hostname" type="string">Host name</option>
      </optgroup>
      <transport method="delete" path="host/%(hostname)s" />
   </command>

   <command name="pxeswitch">
      Change the way the host boots.  At boot, the host may either reboot
      from local disk (--localboot), or it can reinstall (--install). The
      pxeswitch switches the default by changing the configuration on the
      host's bootserver.
      After a successful installation, the host will automatically pxeswitch
      itself back to local disk booting.
      The --configure option forces a reset of the configuration files for this host on
      the bootserver.
      The --list option can be used to change multiple hosts at the same time. The
      argument to --list is a filename containing a list of hostnames, one per line.
      All hosts will be set to the same status.
      <optgroup name="pxeswitch_opts" mandatory="True" fields="any">
         <option name="hostname" type="string" conflicts="list">Host name</option>
         <option name="list" type="file" conflicts="hostname">file containing hostnames</option>
      </optgroup>
      <optgroup name="pxeswitch_action" mandatory="True" fields="any">
         <option name="status" type="boolean" conflicts="configure localboot install firmware blindbuild">display the current status of how the host will boot</option>
         <option name="configure" type="boolean" conflicts="status">(re)initialize the pxeswitch configuration</option>
         <option name="localboot" type="boolean" conflicts="status install firmware blindbuild">set the host to boot from local disk</option>
         <option name="install" type="boolean" conflicts="status localboot firmware blindbuild">set the host to install from the network at next reboot</option>
         <option name="firmware" type="boolean" conflicts="status localboot install blindbuild">set the host to boot its firmware image</option>
         <option name="blindbuild" type="boolean" conflicts="status localboot install firmware">set the host to boot a blindbuild livecd image</option>
      </optgroup>
      <transport method="post" path="host/%(hostname)s/command/pxeswitch" />
      <transport trigger="list" method="post" path="command/pxeswitch/list" />
   </command>

   <command name="reconfigure">
      re-build the configuration settings for the specified host, using
      all of the current service bindings and definitions.  This
      "flushes" any configuration settings, by: regenerating the host
      profile; checking all service bindings against the service maps;
      forcing the bootservers to rebuild their state for this host;
      notifying all datawarehouse tools that the host has been updated;
      notifying the host that it's configuration has been updated. These
      tasks are done even if there is no real change in configuration.
      It's the same as just running "make_aquilon" again, with the
      original arguments.  Any services that are not listed as required
      for the personality or the archetype are dropped unless the
      --keepbindings flag is specified.
      <optgroup name="reconfigure_options" mandatory="True" fields="any">
         <option name="hostname" type="string" conflicts="hostlist">Host name</option>
         <option name="hostlist" type="file" conflicts="hostname">File with one host per line</option>
      </optgroup>
      <optgroup name="reconfigure_optional" mandatory="False">
         <option name="osname" type="string">name of the OS to assign to the host (linux, windows, esx, etc.)</option>
         <option name="osversion" type="string">version of the OS</option>
         <option name="archetype" type="string">Archetype of the personality</option>
         <option name="personality" type="string">Personality of the host</option>
         <option name="buildstatus" type="string">Update host buildstatus to 'build' or 'ready'</option>
         <option name="keepbindings" type="boolean">Preserve service bindings that are not required</option>
         <option name="os" type="string">[Deprecated] OS to assign to host</option>
      </optgroup>
      <transport method="post" path="host/%(hostname)s/command/reconfigure" />
      <transport trigger="hostlist" method="post" path="command/reconfigure/hostlist" />
   </command>

   <command name="add_domain">
      Add a new template domain. This is for testing changes to the templates. The
      new domain will have no hosts when it is freshly created and you should use
      the "manage" command in order to assign some hosts to the domain in order to
      run complete tests.
      <optgroup name="add domain options" mandatory="True" fields="all">
         <option name="domain" type="string">Name of the new domain</option>
      </optgroup>
      <transport method="put" path="domain/%(domain)s" />
   </command>

   <command name="update_archetype">
      Update the meta-information for an archetype.  If the compilable flag
      is not given the attribute will be set to false for the archetype.

      <optgroup name="update_archetype_mandatory" mandatory="True" fields="all">
         <option name="archetype" type="string">Name of the archetype</option>
      </optgroup>
      <optgroup name="update_archetype_options" mandatory="False">
         <option name="compilable" type="boolean">Can hosts be compiled?</option>
      </optgroup>
      <transport method="post" path="archetype/%(archetype)s" />
   </command>

   <command name="update_domain">
      Update the meta-information for a template domain.  This includes
      domain owner, comments about the domain, and the location of the
      pan compiler to use.

      Currently restricted to aqd-admin only.
      <optgroup name="update_domain_mandatory" mandatory="True" fields="all">
         <option name="domain" type="string">Name of the template domain</option>
      </optgroup>
      <optgroup name="update_domain_options" mandatory="True" fields="any">
         <option name="comments" type="string">Comments on the domain</option>
         <option name="owner" type="string">Principal listed as domain owner</option>
         <option name="compiler" type="string">Full path to the panc binary</option>
      </optgroup>
      <transport method="post" path="domain/%(domain)s" />
   </command>

   <command name="del_domain">
      Removes the specified template domain. This will fail if there are hosts still being
      managed by the domain: you must use the "manage" command to reassign those
      hosts to other domains.
      <optgroup name="del_domain_options" mandatory="True" fields="all">
         <option name="domain" type="string">Name of the domain to be deleted</option>
      </optgroup>
      <transport method="delete" path="domain/%(domain)s" />
   </command>

   <command name="get">
      Download a copy of the templates from the specified template domain. The
      templates will be placed in the current directory.
      <optgroup name="get options" mandatory="True" fields="all">
         <option name="domain" type="string">Name of the domain</option>
      </optgroup>
      <transport method="post" path="domain/%(domain)s/command/get" expect="command"/>
   </command>

   <command name="put">
      Upload the templates (and all their changes) in the current directory to the
      specified template domain. You should run "compile" on the domain afterwards to
      confirm any changes.
      <optgroup name="put options" mandatory="True" fields="all">
         <option name="domain" type="string">Name of the new domain</option>
      </optgroup>
      <transport method="post" path="domain/%(domain)s/command/bundle" custom="create_bundle"/>
   </command>

   <command name="deploy">
      Take a template domain and deploy it to production.
      <optgroup name="deploy options" mandatory="True" fields="all">
         <option name="domain" type="string">Name of the domain</option>
      </optgroup>
      <optgroup name="deploy to" mandatory="False" fields="all">
         <option name="to" type="string">
            Name of the domain to deploy to
         </option>
      </optgroup>
      <transport method="post" path="domain/%(domain)s/command/deploy" />
   </command>

   <command name="manage">
      Take a host and make it build its configuration using the specified
      template domain. This allows you to test building hosts using alternate
      templates, or to move a host back to a default production domain once
      testing has completed.
      <optgroup name="manage options" mandatory="True" fields="all">
         <optgroup name="host_or_cluster" fields="any" mandatory="True">
            <option name="hostname" type="string">Name of the host to manage</option>
            <option name="cluster" type="string">Name of the cluster to manage</option></optgroup>
         <option name="domain" type="string">Name of the domain</option>
      </optgroup>
      <transport method="post" path="domain/%(domain)s/command/manage_hostname" trigger="hostname" />
      <transport method="post" trigger="cluster" path="domain/%(domain)s/command/manage_cluster" />
   </command>

   <command name="cat">
      Prints the content of the plenary template in use for any one of the
      given options.  All are exclusive, except --instance and/or --default
      also require --service.
      The --generate option allows you to see what the body of a plenary template
      might look like if it were to be generated right now. This is useful if the
      plenary template does not exist yet because it cannot be compiled. Note
      that template generated on-demand in this way will be incomplete
      (especially if it cannot be compiled) and is purely provided for debugging.
      <optgroup name="cat selector" mandatory="True" fields="any">
         <option name="hostname" type="string" conflicts="machine cluster service instance default nasinfo">Name of the host</option>
         <option name="machine" type="string" conflicts="hostname cluster service instance default nasinfo">Name of the machine</option>
         <option name="cluster" type="string" conflicts="hostname machine service instance default nasinfo">Name of the machine</option>
         <option name="service" type="string" conflicts="hostname machine cluster nasinfo">Name of the service</option>
         <option name="instance" type="string" conflicts="hostname machine cluster nasinfo">Name of the service instance</option>
	 <option name="default" type="boolean" conflicts="hostname machine cluster nasinfo">Show the default client config for the service/instance</option>
	 <option name="nasinfo" type="string" conflicts="hostname machine cluster service instance default">Show the default client config for the service/instance</option>
      </optgroup>
      <optgroup name="cat options" fields="any">
          <option name="generate" type="boolean">Show the plenary template as it would be generated</option>
      </optgroup>
      <transport trigger="hostname" method="get" path="host/%(hostname)s/plenary" />
      <transport trigger="machine" method="get" path="machine/%(machine)s/plenary" />
      <transport trigger="service" method="get" path="service/%(service)s/plenary" />
      <transport trigger="instance" method="get" path="service/%(service)s/instance/%(instance)s/plenary" />
      <transport trigger="cluster" method="get" path="cluster/any/%(cluster)s/plenary" />
      <transport trigger="nasinfo" method="get" path="nasinfo/%(nasinfo)s/plenary" />
   </command>

   <command name="sync">
      Flush all plenary templates within the specified domain. This is only required
      if the broker has somehow become out-of-sync between the templates that live
      on the local disk, and the state within the database.
      <optgroup name="sync options" mandatory="True" fields="all">
         <option name="domain" type="string">Name of the domain</option>
      </optgroup>
      <transport method="post" path="domain/%(domain)s/command/sync" expect="command"/>
   </command>

   <command name="add_location">
      Create a new location within the database, which can then be used to place
      hosts and within service maps. Names of all locations are globally unique.
      For example, you can only have one city 'ln' anywhere, and only one chassis called "np3c5".
      <optgroup name="add_location_opts" mandatory="True" fields="all">
         <option name="name" type="string">Short name of new location</option>
         <option name="fullname" type="string">Full/descriptive name of new location</option>
         <option name="type" type="string">Location type</option>
         <option name="parentname" type="string">Short name of parent</option>
         <option name="parenttype" type="string">Location type of parent</option>
         <option name="comments" type="string">Comments about the location</option>
      </optgroup>
      <transport method="put" path="location/%(type)s/%(name)s" />
   </command>

   <command name="show_location">
      Shows all locations of a given type
      or information about a specific location type and name.
      <optgroup name="show_location_opts" mandatory="True" fields="all">
         <option name="type" type="string">Location type</option>
      </optgroup>
      <optgroup name="show_location_optional" mandatory="False" fields="all">
         <option name="name" type="string">Host name</option>
      </optgroup>
      <transport trigger="type" method="get" path="location/%(type)s" />
      <transport trigger="name" method="get" path="location/%(type)s/%(name)s" />
   </command>

   <command name="del_location">
      Remove a location from the database. The command will fail if there
      are any hosts at that location, or if the location is used within any service maps.
      <optgroup name="del_location_opts" mandatory="True" fields="all">
         <option name="name" type="string">Short name of new location</option>
         <option name="type" type="string">Location type</option>
      </optgroup>
      <transport method="delete" path="location/%(type)s/%(name)s" />
   </command>

   <command name="add_chassis">
      Add a new chassis to the database.  A chassis can contain multiple blades. Management tasks for the blades are typically performed by connecting to the chassis itself, and so the chassis name must exist within DNS.
      <optgroup name="add_chassis_input" mandatory="True" fields="all">
         <option name="chassis" type="string">FQDN name of the new chassis</option>
         <option name="rack" type="string">Name of the rack location for this chassis</option>
	 <option name="model" type="string">Model of chassis to create. Use 'show model --type chassis' to see a list of valid models</option>
      </optgroup>
      <optgroup name="optional_opts">
	 <option name="serial" type="string">serial number</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="chassis/%(chassis)s" />
   </command>

   <command name="show_chassis">
      Show the chassis list, or details about a particular chassis.
      <optgroup name="show_chassis_opts">
         <option name="chassis" type="string">chassis name</option>
      </optgroup>
      <transport method="get" path="location/chassis" />
      <transport trigger="chassis" method="get" path="chassis/%(chassis)s" />
   </command>

   <command name="del_chassis">
      Delete a chassis. See also del_location.
      <optgroup name="del_chassis_opts" mandatory="True" fields="all">
         <option name="chassis" type="string">chassis name</option>
      </optgroup>
      <transport method="delete" path="chassis/%(chassis)s" />
   </command>

   <command name="add_rack">
      Add a new rack to the database.  To add a rack named dd120 on tile H13,
      use --building=dd --rackid=120 --row=H --column=13.  The rackid
      option can also be prefixed by building name, so using
      --building=dd --rackid=dd120 --row=H --column=13 would also work.
      See also add_location.
      <optgroup name="add_rack_input" mandatory="True" fields="all">
         <option name="rackid" type="string">Name of the new rack, or just the id number</option>
         <option name="row" type="string">Row of the tile location</option>
         <option name="column" type="string">Column of the tile location</option>
         <optgroup name="add_rack_parent" mandatory="True" fields="any">
            <option name="building" type="string" conflicts="room">Name of the building that houses the rack</option>
            <option name="room" type="string" conflicts="building">Name of the room that houses the rack</option>
         </optgroup>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="fullname" type="string">Full, descriptive name</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="location/add_rack_to_building/%(building)s/%(rackid)s" />
      <transport method="put" trigger="room" path="location/add_rack_to_room/%(room)s/%(rackid)s" />
   </command>

   <command name="update_rack">
      Update the row and column parameters for a rack.
      <optgroup name="update_rack_input" mandatory="True" fields="all">
         <option name="name" type="string">Name of the rack</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="row" type="string">Row of the tile location</option>
         <option name="column" type="string">Column of the tile location</option>
         <option name="fullname" type="string">Full, descriptive name</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="post" path="location/rack/%(name)s" />
   </command>

   <command name="show_rack">
      Show the rack list, or details about a particular rack.
      <optgroup name="show_rack_opts" mandatory="True" fields="any">
         <option name="name" type="string" conflicts="all">rack name</option>
         <option name="all" type="boolean" conflicts="name">all</option>
      </optgroup>
      <transport method="get" path="location/rack" />
      <transport trigger="name" method="get" path="location/rack/%(name)s" />
   </command>

   <command name="del_rack">
      Delete a rack. See also del_location.
      <optgroup name="del_rack_opts" mandatory="True" fields="all">
         <option name="name" type="string">rack name</option>
      </optgroup>
      <transport method="delete" path="location/rack/%(name)s" />
   </command>

   <command name="add_building">
      Add a new building to the database. See also add_location.
      <optgroup name="add_building_input" mandatory="True" fields="all">
         <option name="name" type="string">Name of the new building</option>
         <option name="city" type="string">Name of the city that contains the building</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="fullname" type="string">Full, descriptive name</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="location/add_building/%(city)s/%(name)s" />
   </command>

   <command name="show_building">
      Show the building list, or details about a particular building.
      <optgroup name="show_building_opts">
         <option name="name" type="string">building name</option>
      </optgroup>
      <transport method="get" path="location/building" />
      <transport trigger="name" method="get" path="location/building/%(name)s" />
   </command>

   <command name="del_building">
      Delete a building. See also del_location.
      <optgroup name="del_building_opts" mandatory="True" fields="all">
         <option name="name" type="string">building name</option>
      </optgroup>
      <transport method="delete" path="location/building/%(name)s" />
   </command>

   <command name="add_room">
      Add a new room to the database. See also add_location.
      <optgroup name="add_room_input" mandatory="True" fields="all">
         <option name="name" type="string">Name of the new room</option>
         <option name="building" type="string">Name of the building that contains the room</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="fullname" type="string">Full, descriptive name</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="location/add_room/%(building)s/%(name)s" />
   </command>

   <command name="show_room">
      Show the room list, or details about a particular room.
      <optgroup name="show_room_opts" mandatory="True" fields="any">
         <option name="name" type="string">room name</option>
         <option name="all" type="boolean">show all</option>
      </optgroup>
      <transport method="get" path="location/room" />
      <transport trigger="name" method="get" path="location/room/%(name)s" />
   </command>

   <command name="del_room">
      Delete a room. See also del_location.
      <optgroup name="del_room_opts" mandatory="True" fields="all">
         <option name="name" type="string">room name</option>
      </optgroup>
      <transport method="delete" path="location/room/%(name)s" />
   </command>

   <command name="show_campus">
      Show the list of campuses, or details about a particular campus.
      <optgroup name="show_campus_opts" mandatory="True" fields="any">
         <option name="name" type="string">campus name</option>
         <option name="all" type="boolean">show all campuses</option>
      </optgroup>
      <transport method="get" path="location/campus" />
      <transport trigger="name" method="get" path="location/campus/%(name)s" />
   </command>

   <command name="add_city">
      Add a new city to the database. See also add_location.
      <optgroup name="add_city_options" mandatory="True" fields="all">
         <option name="name" type="string">Name of the new city</option>
         <option name="country" type="string">Name of the country that contains the city</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="fullname" type="string">Full, descriptive name</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="location/add_city/%(country)s/%(name)s" />
   </command>

   <command name="show_city">
      Show the list of cities, or details about a particular city.
      <optgroup name="show_city_opts">
         <option name="name" type="string">city name</option>
      </optgroup>
      <transport method="get" path="location/city" />
      <transport trigger="name" method="get" path="location/city/%(name)s" />
   </command>

   <command name="del_city">
      Delete a city. See also del_location.
      <optgroup name="del_city_opts" mandatory="True" fields="all">
         <option name="name" type="string">city name</option>
      </optgroup>
      <transport method="delete" path="location/city/%(name)s" />
   </command>

   <command name="add_country">
      Add a new country to the database. See also add_location.
      <optgroup name="add_country_options" mandatory="True" fields="all">
         <option name="name" type="string">Name of the new country</option>
         <option name="continent" type="string">Name of the continent that contains the country</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="fullname" type="string">Full, descriptive name</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="location/add_country/%(continent)s/%(name)s" />
   </command>

   <command name="show_country">
      Show the list of countries, or details about a particular country.
      <optgroup name="show_country_opts">
         <option name="name" type="string">country name</option>
      </optgroup>
      <transport method="get" path="location/country" />
      <transport trigger="name" method="get" path="location/country/%(name)s" />
   </command>

   <command name="del_country">
      Delete a country. See also del_location.
      <optgroup name="del_country_opts" mandatory="True" fields="all">
         <option name="name" type="string">country name</option>
      </optgroup>
      <transport method="delete" path="location/country/%(name)s" />
   </command>

   <command name="add_continent">
      Add a new continent to the database. See also add_location.
      <optgroup name="add_continent_options" mandatory="True" fields="all">
         <option name="name" type="string">Name of the new continent</option>
         <option name="hub" type="string">Name of the hub, which the continent belongs to</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="fullname" type="string">Full, descriptive name</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="location/add_continent/%(hub)s/%(name)s" />
   </command>

   <command name="show_continent">
      Show the list of continents, or details about a particular continent.
      <optgroup name="show_continent_opts">
         <option name="name" type="string">continent name</option>
      </optgroup>
      <transport method="get" path="location/continent" />
      <transport trigger="name" method="get" path="location/continent/%(name)s" />
   </command>

   <command name="del_continent">
      Delete a continent. See also del_location.
      <optgroup name="del_continent_opts" mandatory="True" fields="all">
         <option name="name" type="string">continent name</option>
      </optgroup>
      <transport method="delete" path="location/continent/%(name)s" />
   </command>

   <command name="add_organization">
      Add a new organization.
      <optgroup name="add_org_options" mandatory="True" fields="all">
         <option name="organization" type="string">Name of the new organization</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="fullname" type="string">Full, descriptive name</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="location/add_organization/%(organization)s" />
   </command>

   <command name="del_organization">
      Delete an organization. This will fail if the organization contains
      any hubs.
      <optgroup name="del_org_options" mandatory="True" fields="all">
         <option name="organization" type="string">Name of the organization</option>
      </optgroup>
      <transport method="delete" path="location/organization/%(organization)s" />
   </command>

   <command name="show_organization">
      Show an organization.
      <optgroup name="show_org_options" mandatory="False" fields="all">
         <option name="organization" type="string">Name of the organization</option>
      </optgroup>
      <transport method="get" path="location/organization" />
      <transport trigger="organization" method="get" path="location/organization/%(organization)s" />
   </command>

   <command name="add_hub">
      Add a new hub to the database. See also add_location.
      <optgroup name="add_hub_options" mandatory="True" fields="all">
         <option name="name" type="string">Name of the new hub</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="fullname" type="string">Full, descriptive (region) name</option>
         <option name="organization" type="string">The owning organization of the hub</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="location/add_hub/%(name)s" />
   </command>

   <command name="show_hub">
      Show the list of hubs, or details about a particular hub.
      <optgroup name="show_hub_opts">
         <option name="name" type="string">hub name</option>
      </optgroup>
      <transport method="get" path="location/hub" />
      <transport trigger="name" method="get" path="location/hub/%(name)s" />
   </command>

   <command name="del_hub">
      Delete a hub. See also del_location.
      <optgroup name="del_hub_opts" mandatory="True" fields="all">
         <option name="name" type="string">hub name</option>
      </optgroup>
      <transport method="delete" path="location/hub/%(name)s" />
   </command>

  <command name="add_archetype">
      Create an archetype.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="archetype" type="string">The name to create</option>
      </optgroup>
      <transport method="put" path="archetype/%(archetype)s" />
  </command>

  <command name="del_archetype">
      Delete an archetype.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="archetype" type="string">The name to delete</option>
      </optgroup>
      <transport method="delete" path="archetype/%(archetype)s" />
  </command>


  <command name="add_personality">
      Create a personality. A default template will be created, however
      this default will be insufficient for real usage and will need to
      be edited in order to provide realistic information for such things as
      cost allocations, usage, etc.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="personality" type="string">The name to create</option>
         <option name="archetype" type="string">Which archetype to use</option>
      </optgroup>
      <transport method="put" path="personality/%(archetype)s/%(personality)s" />
  </command>

  <command name="add_vendor">
      Create a vendor definition.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="vendor" type="string">The name of the vendor</option>
      </optgroup>
      <transport method="put" path="vendor/%(vendor)s" />
  </command>

  <command name="del_vendor">
      Remove a vendor definition.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="vendor" type="string">The name of the vendor</option>
      </optgroup>
      <transport method="delete" path="vendor/%(vendor)s" />
  </command>

  <command name="show_vendor">
      Show currently defined vendors.
      <optgroup name="mandatory_options" mandatory="True" fields="any">
         <option name="vendor" type="string">The name of the vendor</option>
         <option name="all" type="boolean" conflicts="vendor">Show all vendors</option>
      </optgroup>
      <transport trigger="vendor" method="get" path="vendor/%(vendor)s" />
      <transport trigger="all" method="get" path="vendor"/>
  </command>

  <command name="add_os">
      Create an operating system definition.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="osname" type="string">The name of the operating system</option>
         <option name="osversion" type="string">The version of the operating system</option>
         <option name="archetype" type="string">Which archetype the OS is being added to</option>
      </optgroup>
      <optgroup name="add_os_optional" mandatory="False">
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="os/%(osname)s/%(osversion)s/%(archetype)s" />
  </command>

  <command name="del_os">
      Delete an operating system definition.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="osname" type="string">The name of the operating system</option>
         <option name="osversion" type="string">The version of the operating system</option>
         <option name="archetype" type="string">Which archetype the OS is being deleted from</option>
      </optgroup>
      <transport method="delete" path="os/%(osname)s/%(osversion)s/%(archetype)s" />
  </command>

  <command name="show_os">
      Show an operating system definition.
      <optgroup name="show_os_opts" mandatory="True" fields="any">
         <option name="osname" type="string">The name of the operating system</option>
         <option name="osversion" type="string">The version of the operating system</option>
         <option name="archetype" type="string">The archetype to search within</option>
         <option name="all" type="boolean">Show all operating systems</option>
      </optgroup>
      <transport method="get" path="os"/>
  </command>

  <command name="del_personality">
      Delete a personality. This command will fail if any hosts are currently
      using the personality.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="personality" type="string">The name to delete</option>
         <option name="archetype" type="string">Which archetype to use</option>
      </optgroup>
      <transport method="delete" path="personality/%(archetype)s/%(personality)s" />
  </command>

  <command name="show_personality">
      Show personality details.  Specifying both name and archetype will
      uniquely identify a personality.

      If the domain option is given that domain will be searched for
      information about the personality's thresholds.
      <optgroup name="show_personality_opts" mandatory="True" fields="any">
         <option name="personality" type="string" conflicts="all">personality name (same name may be in multiple archetypes)</option>
         <option name="archetype" type="string" conflicts="all">which archetype to use</option>
         <option name="all" type="boolean" conflicts="personality archetype">all</option>
      </optgroup>
      <optgroup name="show_personality_optional" mandatory="False">
         <option name="domain" type="string">Domain to check for threshold information</option>
      </optgroup>
      <transport method="get" path="personality" />
  </command>

   <command name="make">
      Build a host configuration.  Any required services which are not bound
      will cause an implicit bind_client to occur.  Any services that
      are not listed as required for the personality or the archetype
      are dropped unless the --keepbindings flag is specified.  The host
      information will be compiled into a working configuration.  Any
      errors in creating the configuration will be printed to the screen
      and cause the command to fail.  If the configuration is
      successfully created, then the new configuration may be
      "advertised" to the host itself, to the data warehouse and to the
      bootservers, making the host ready to build.  If this is a new host, then
      The bootservers will
      put the host into "install" mode of pxeswitch.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="hostname" type="string">Host name to make</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="osname" type="string">name of the OS to assign to the host (linux, windows, esx, etc.)</option>
         <option name="osversion" type="string">version of the OS</option>
         <option name="archetype" type="string">Archetype of the host (defaults to aquilon)</option>
         <option name="personality" type="string">Personality of the host</option>
         <option name="buildstatus" type="string">Build Status can be updated to 'build' or 'ready'.</option>
         <option name="keepbindings" type="boolean">Preserve service bindings that are not required</option>
         <option name="os" type="string">[Deprecated] OS to assign to host</option>
      </optgroup>
      <transport method="post" path="host/%(hostname)s/command/make" />
   </command>

   <command name="make_aquilon">
      Create an aquilon host.  Any required services which are not bound
      will cause an implicit bind_client to occur.  Any services that
      are not listed as required for the personality or the archetype
      are dropped unless the --keepbindings flag is specified.  The host
      information will be compiled into a working configuration.  Any
      errors in creating the configuration will be printed to the screen
      and cause the command to fail.  If the configuration is
      successfully created, then the new configuration will be
      "advertised" to the host itself, to the data warehouse and to the
      bootservers, making the host ready to build.  The bootservers will
      put the host into "install" mode of pxeswitch.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="hostname" type="string">Host name to make</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="osname" type="string">name of the OS to assign to the host (linux, windows, esx, etc.)</option>
         <option name="osversion" type="string">version of the OS</option>
         <option name="personality" type="string">Personality of the host</option>
         <option name="buildstatus" type="string">Build Status can be updated to 'build' or 'ready'.</option>
         <option name="keepbindings" type="boolean">Preserve service bindings that are not required</option>
         <option name="os" type="string">[Deprecated] OS to assign to host</option>
      </optgroup>
      <transport method="post" path="host/%(hostname)s/command/make_aquilon" />
   </command>

   <command name="make_cluster">
      Build a cluster configuration.  Any cluster aligned services which
      are not bound will cause an implicit bind_cluster to occur.  Any
      services that are not listed as aligned for the cluster type
      are dropped unless the --keepbindings flag is specified.  The cluster
      information will be compiled into a working configuration.  Any
      errors in creating the configuration will be printed to the screen
      and cause the command to fail.  If the configuration is successfully
      created, then the new configuration may be "advertised" to the cluster
      itself, to the data warehouse and to the bootservers, making the
      cluster ready to build.
      <optgroup name="mandatory_options" mandatory="True" fields="all">
         <option name="cluster" type="string">Cluster name to make</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="keepbindings" type="boolean">Preserve service bindings that are not marked as aligned</option>
      </optgroup>
      <transport method="post" path="cluster/any/%(cluster)s/command/make" />
   </command>

   <command name="add_machine">
      Create a new machine at a given location.

      If the model was created with machine specifications (values for
      cpuname, cpuvendor, cpuspeed, cpucount, memory) they do not need
      to be given to this command - the model info will be used as a default.

      However, if the model does not have defaults, they all need to be given.

      If the hardware is virtual the --cluster option should be used to
      indicate the location indirectly.  Whether or not hardware is
      virtual is indicated by the machine type of the model.
      <optgroup name="add_machine_opts" mandatory="True" fields="all">
         <option name="machine" type="string">machine name</option>
         <option name="model" type="string">machine model</option>
      </optgroup>
      <optgroup name="add_machine_specs_opts" mandatory="False">
	 <option name="cpuname" type="string">cpu name</option>
	 <option name="cpuvendor" type="string">cpu vendor</option>
	 <option name="cpuspeed" type="string">cpu speed</option>
	 <option name="cpucount" type="string">cpu count</option>
	 <option name="memory" type="string">memory in MB</option>
      </optgroup>
      <optgroup name="add_machine_location_opts" mandatory="True" fields="any">
	 <optgroup name="add_machine_chassis_opts" fields="all">
            <option name="chassis" type="string">Chassis name</option>
            <option name="slot" type="string">Chassis slot</option>
         </optgroup>
         <option name="rack" type="string">Rack name</option>
         <option name="desk" type="string">Desk name</option>
         <optgroup name="add_machine_cluster_opts" fields="all">
            <option name="cluster" type="string" conflicts="chassis rack desk">Cluster name</option>
         </optgroup>
      </optgroup>
      <optgroup name="add_machine_optional">
	 <option name="serial" type="string">serial number</option>
      </optgroup>
      <transport method="put" path="machine/%(machine)s" />
   </command>

   <command name="update_machine">
      Update a machine by hardware name or hostname.

      Updating the model for a machine will not automatically update
      the machine to the new model's default specifications.  To do so, give
      the new information (cpu, count, memory) at the same time.
      <optgroup name="update_machine_opts" mandatory="True" fields="any">
         <option name="machine" type="string" conflicts="hostname">machine name</option>
         <option name="hostname" type="string" conflicts="machine">fully qualified host name</option>
      </optgroup>
      <optgroup name="update_machine_opts" mandatory="False" fields="any">
         <option name="model" type="string">machine model</option>
         <option name="cpuname" type="string">cpu name</option>
         <option name="cpuvendor" type="string">cpu vendor</option>
         <option name="cpuspeed" type="string">cpu speed</option>
         <option name="cpucount" type="string">cpu count</option>
         <option name="memory" type="string">memory in MB</option>
         <option name="chassis" type="string">chassis name</option>
         <option name="slot" type="string">chassis slot</option>
         <option name="clearchassis" type="boolean">remove chassis and slot information</option>
         <option name="multislot" type="boolean">use to record machine as taking multiple slots in a chassis</option>
         <option name="rack" type="string">rack name</option>
         <option name="desk" type="string">desk name</option>
         <option name="serial" type="string">serial number</option>
         <option name="cluster" type="string">Cluster name</option>
      </optgroup>
      <transport method="post" trigger="hostname" path="host/%(hostname)s/command/update_hardware" />
      <transport method="post" path="machine/%(machine)s/command/update" />
   </command>

   <command name="show_machine">
      Show the hardware configuration of the named machine.

      Supported options for --format: raw, csv.

      The 'csv' format contains the following fields, in this order:
      Machine name, Rack, Building, Vendor name, Model name, Serial number,
      Interface name, Interface MAC address, Interface IP address.

      If the machine has multiple interfaces, then there will be a separate
      line for each.
      <optgroup name="show_machine_opts" mandatory="True" fields="any">
         <option name="machine" type="string">machine name</option>
	 <option name="all" type="boolean" conflicts="machine">all</option>
         <optgroup name="show_machine_location_opts" mandatory="False">
            <option name="chassis" type="string">Chassis name</option>
	    <option name="slot" type="string">Chassis Slot</option>
            <option name="rack" type="string">Rack name</option>
            <option name="desk" type="string">Desk name</option>
         </optgroup>
         <option name="model" type="string">machine model</option>
      </optgroup>
      <transport trigger="all" method="get" path="machine" />
      <transport trigger="machine" method="get" path="machine/%(machine)s" />
      <transport method="post" path="machine" />
   </command>

   <command name="del_machine">
      Delete the specified machine. This command will fail if the machine
      is being used: you must del_host before you can del_machine.
      <optgroup name="del_machine_opts" mandatory="True" fields="all">
         <option name="machine" type="string">machine name</option>
      </optgroup>
      <transport method="delete" path="machine/%(machine)s" />
   </command>

   <command name="add_tor_switch">
      Create a new Top-Of-Rack (TOR) network switch.

      If the model was created with machine specifications (values for
      cpuname, cpuvendor, cpuspeed, cpucount, memory) they do not need
      to be given to this command - the model info will be used as a default.

      However, if the model does not have defaults, they all need to be given.

      See the help for add_rack for more information about the rack options.
      The --rack option can only be used with a preexisting rack.  If given
      --building, --rackid, --rackrow, and --rackcolumn, the rack will be
      created if needed.
      <optgroup name="add_tor_switch_opts" mandatory="True" fields="all">
         <option name="tor_switch" type="string">tor_switch name</option>
         <option name="model" type="string">tor_switch model</option>
      </optgroup>
      <optgroup name="add_tor_switch_location" mandatory="True" fields="any">
         <option name="rack" type="string" conflicts="building">Rack name</option>
         <optgroup name="add_tor_switch_new_rack" fields="all">
            <option name="rackid" type="string" conflicts="rack">Rack id/number</option>
            <option name="rackrow" type="string" conflicts="rack">Rack Row (letters only)</option>
            <option name="rackcolumn" type="string" conflicts="rack">Rack Column (numbers only)</option>
            <optgroup name="add_tor_switch_rack_parent" fields="any">
               <option name="building" type="string" conflicts="rack room">Building</option>
               <option name="room" type="string" conflicts="rack building">Room</option>
            </optgroup>
         </optgroup>
      </optgroup>
      <optgroup name="add_tor_switch_primary" mandatory="False" fields="all">
         <option name="interface" type="string">Interface name (like xge49)</option>
         <option name="mac" type="string">MAC address of the interface</option>
         <option name="ip" type="string">IP address of the interface</option>
      </optgroup>
      <optgroup name="add_tor_switch_specs_opts" mandatory="False">
	 <option name="cpuname" type="string">cpu name</option>
	 <option name="cpuvendor" type="string">cpu vendor</option>
	 <option name="cpuspeed" type="string">cpu speed</option>
	 <option name="cpucount" type="string">cpu count</option>
	 <option name="memory" type="string">memory in MB</option>
      </optgroup>
      <optgroup name="add_tor_switch_optional">
	 <option name="serial" type="string">serial number</option>
      </optgroup>
      <transport method="put" path="tor_switch/%(tor_switch)s" />
   </command>

   <command name="show_tor_switch">
      Show the configuration information for the specified switch.

      Supported options for --format: raw, csv.

      The 'csv' format contains the following fields, in this order:
      FQDN, Rack, Building, Vendor name, Model name, Serial number,
      Interface name, Interface MAC address, Interface IP address.

      If the switch has multiple interfaces assigned, then there will be a
      separate line for each.
      <optgroup name="show_tor_switch_opts" mandatory="True" fields="any">
         <option name="tor_switch" type="string">tor_switch name</option>
         <option name="rack" type="string">Rack name</option>
         <option name="model" type="string">tor_switch model</option>
         <option name="all" type="boolean">show all</option>
      </optgroup>
      <transport trigger="tor_switch" method="get" path="tor_switch/%(tor_switch)s" />
      <transport method="get" path="find/tor_switch" />
   </command>

   <command name="del_tor_switch">
      Delete the specified TOR switch.
      <optgroup name="del_tor_switch_opts" mandatory="True" fields="all">
         <option name="tor_switch" type="string">tor_switch name</option>
      </optgroup>
      <transport method="delete" path="tor_switch/%(tor_switch)s" />
   </command>

   <command name="poll_tor_switch">
      <optgroup name="poll_tor_switch_opts" mandatory="True" fields="any">
         <option name="tor_switch" type="string" conflicts="rack">tor_switch name</option>
         <option name="rack" type="string" conflicts="tor_switch">Rack name</option>
      </optgroup>
      <optgroup name="poll_tor_switch optional" mandatory="False" fields="any">
         <option name="clear" type="boolean">Clear any previously observed MACs before polling</option>
         <option name="vlan" type="boolean">Additionally poll for vlan/subnet mappings</option>
      </optgroup>
      <transport trigger="tor_switch" method="post" path="tor_switch/%(tor_switch)s/command/poll" />
      <transport method="post" path="poll/rack/%(rack)s" />
   </command>

   <command name="show_principal">
      Show the entitlements for a given username.
      <optgroup name="show_role_opts" mandatory="False">
         <option name="principal" type="string">User Principal to check</option>
      </optgroup>
      <transport method="get" path="principal" />
      <transport trigger="principal" method="get" path="principal/%(principal)s" />
   </command>

   <command name="permission">
      Modify the entitlements for a user.
      <optgroup name="permission_opts" mandatory="True">
         <option name="principal" type="string">User Principal (e.g. njw@is1.morgan) to change</option>
         <option name="role" type="string">Role to use</option>
      </optgroup>
      <optgroup name="permission_optional_opts">
         <option name="createuser" type="boolean">Create an entry for the user if one does not exist</option>
         <option name="createrealm" type="boolean">Create an entry for the realm if one does not exist (implies --createuser)</option>
      </optgroup>
      <transport method="put" path="principal/%(principal)s/role" />
   </command>

   <command name="add_dns_domain">
      Add a new DNS subdomain.
      <optgroup name="add_dns_domain_options" mandatory="True" fields="all">
         <option name="dns_domain" type="string">Name of the new DNS domain</option>
      </optgroup>
      <optgroup name="add_dns_domain_optional_options" mandatory="False">
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="dns_domain/%(dns_domain)s" />
   </command>

   <command name="show_dns_domain">
      Show the configuration of the specified DNS domain. If --all is specified, then
      the configuration of all DNS domains will be output.
      <optgroup name="del_dns_domain_options" mandatory="True" fields="any">
         <option name="dns_domain" type="string" conflicts="all">Name of the DNS domain</option>
         <option name="all" type="boolean" conflicts="dns_domain">Show all DNS domains</option>
      </optgroup>
      <transport trigger="dns_domain" method="get" path="dns_domain/%(dns_domain)s" />
      <transport method="get" path="dns_domain" />
   </command>

   <command name="del_dns_domain">
      Delete the named DNS subdomain.
      <optgroup name="del_dns_domain_options" mandatory="True" fields="all">
         <option name="dns_domain" type="string">Name of the DNS domain</option>
      </optgroup>
      <transport method="delete" path="dns_domain/%(dns_domain)s" />
   </command>

   <command name="add_metacluster">
      Add a new metacluster.
      <optgroup name="add_metacluster_req" mandatory="True" fields="all">
         <option name="metacluster" type="string">Name of the new metacluster</option>
      </optgroup>
      <optgroup name="add_metacluster_options" mandatory="False">
         <option name="max_members" type="string">Comments</option>
         <option name="max_shares" type="string">Comments</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="metacluster/%(metacluster)s" />
   </command>

   <command name="show_metacluster">
      Show details for a metacluster.
      <optgroup name="show_metacluster_req" mandatory="True" fields="any">
         <option name="metacluster" type="string">Name of the metacluster</option>
         <option name="all" type="boolean">Show all</option>
      </optgroup>
      <transport method="get" path="metacluster" />
      <transport method="get" trigger="metacluster" path="metacluster/%(metacluster)s" />
   </command>

   <command name="update_metacluster">
      Update a metacluster.
      <optgroup name="update_metacluster_req" mandatory="True" fields="all">
         <option name="metacluster" type="string">Name of the metacluster</option>
      </optgroup>
      <optgroup name="update_metacluster_options" mandatory="False">
         <option name="max_members" type="string">Comments</option>
         <option name="max_shares" type="string">Comments</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="post" path="metacluster/%(metacluster)s" />
   </command>

   <command name="del_metacluster">
      Delete the metacluster.
      <optgroup name="del_metacluster_req" mandatory="True" fields="all">
         <option name="metacluster" type="string">Name of the metacluster</option>
      </optgroup>
      <transport method="delete" path="metacluster/%(metacluster)s" />
   </command>

   <command name="add_esx_cluster">
      Add a new ESX cluster.

      Each ESX cluster must belong to a metacluster.

      Two constraints must be defined.  The cluster has a location constraint.
      All cluster vmhosts must be within the same location.  All of the
      cluster's vmhosts must also have the same personality.

      The max_members option can be set to define the maximum number of
      vmhosts that can be members of the cluster.

      The "down hosts threshold" is the number of hosts needed as "effective
      spares" per hardware model and cluster layout.  This value is used
      for cluster montioring alerts.

      The vm_to_host_ratio constrains the number of virtual machines
      allowed on the cluster based on the number of vmhosts.  This
      ratio is checked when adding virtual machines to a cluster or
      removing vmhosts from a cluster.  The check assumes
      down_hosts_threshold less hosts than are currently bound to the
      cluster.
      <optgroup name="add_esx_cluster_req" mandatory="True" fields="all">
         <option name="cluster" type="string">Name of the new esx_cluster</option>
         <option name="metacluster" type="string">Name of the metacluster containing this cluster</option>
         <option name="down_hosts_threshold">Number of vmhosts that can be down before monitoring alarms trigger</option>
         <optgroup name="add_cluster_location_opts" fields="any">
            <option name="organization" type="string">Organization</option>
            <option name="hub" type="string">Hub</option>
            <option name="continent" type="string">Continent</option>
            <option name="country" type="string">Country</option>
            <option name="city" type="string">City</option>
            <option name="building" type="string">Building</option>
            <option name="room" type="string">Room</option>
            <option name="rack" type="string">Rack</option>
            <option name="desk" type="string">Desk</option>
         </optgroup>
         <option name="archetype" type="string">Archetype name</option>
         <option name="personality" type="string">Personality name</option>
         <option name="domain" type="string">Name of template domain/sandbox</option>
      </optgroup>
      <optgroup name="add_esx_cluster_options" mandatory="False">
         <option name="max_members" type="string">Comments</option>
         <option name="vm_to_host_ratio" type="string">Ratio of virtual machines to ESX servers</option>
         <option name="tor_switch" type="string">ToR switch in use by the cluster</option>
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="cluster/esx/%(cluster)s" />
   </command>

   <command name="show_esx_cluster">
      Show details for an ESX cluster.
      <optgroup name="show_cluster_req" mandatory="True" fields="any">
         <option name="cluster" type="string">Name of the cluster</option>
         <option name="all" type="boolean">Name of the cluster</option>
      </optgroup>
      <transport method="get" trigger="cluster" path="cluster/esx/%(cluster)s" />
      <transport method="get" path="cluster/esx" />
   </command>

   <command name="update_esx_cluster">
      Update an ESX cluster.

      The cluster vmhost members are constrained to be in the same location
      and have the same personality.  An attempt to update any constraint
      that cannot be satisfied will fail.
      <optgroup name="update_esx_cluster_req" mandatory="True" fields="all">
         <option name="cluster" type="string">Name of the ESX cluster</option>
      </optgroup>
      <optgroup name="update_esx_cluster_options" mandatory="False">
         <option name="archetype" type="string">Archetype Name</option>
         <option name="personality" type="string">Personality Name</option>
         <option name="down_hosts_threshold">Down hosts threshold</option>
         <option name="max_members" type="string">Max allowed vmhost members</option>
         <option name="vm_to_host_ratio" type="string">Ratio of virtual machines to ESX servers</option>
         <option name="tor_switch" type="string">Set the switch in use by the cluster.  An empty string removes the setting.</option>
         <option name="fix_location" type="boolean">Set the location based on cluster membership.</option>
         <option name="comments" type="string">Comments</option>
         <optgroup name="update_cluster_location_opts" fields="any">
	    <option name="organization" type="string">Organization</option>
	    <option name="hub" type="string">Hub</option>
	    <option name="continent" type="string">Continent</option>
	    <option name="country" type="string">Country</option>
	    <option name="city" type="string">City</option>
	    <option name="building" type="string">Building</option>
	    <option name="room" type="string">Room</option>
	    <option name="rack" type="string">Rack</option>
	    <option name="desk" type="string">Desk</option>
         </optgroup>
      </optgroup>
      <transport method="post" path="cluster/esx/%(cluster)s" />
   </command>

   <command name="del_esx_cluster">
      Delete the ESX cluster.
      <optgroup name="del_cluster_req" mandatory="True" fields="all">
         <option name="cluster" type="string">Name of the cluster</option>
      </optgroup>
      <transport method="delete" path="cluster/esx/%(cluster)s" />
   </command>

   <command name="rebind_metacluster">
      Change metacluster bindings.

      This will move the cluster into the named metacluster.
      <optgroup name="rebind_client_opts" mandatory="True" fields="all">
         <option name="metacluster" type="string">MetaCluster name</option>
         <option name="cluster" type="string">Cluster name</option>
      </optgroup>
      <transport method="post" path="metacluster/%(metacluster)s/cluster/%(cluster)s/rebind" />
   </command>

   <command name="bind_esx_cluster">
      Bind a vmhost or a service instance to the named cluster.

      If binding a vmhost that is already bound to a different cluster this
      command will fail.

      If binding a service instance for a service that is already bound to
      a different instance this command will fail.
      <optgroup name="bind_esx_cluster_opts" mandatory="True" fields="all">
         <option name="cluster" type="string">Cluster name</option>
         <optgroup name="bind_esx_cluster_object" mandatory="True" fields="any">
            <option name="hostname" type="string" conflicts="service">Server name</option>
            <optgroup name="bind_esx_cluster_service" mandatory="False" fields="all">
               <option name="service" type="string" conflicts="hostname">Service name</option>
               <option name="instance" type="string">Service Instance</option>
            </optgroup>
         </optgroup>
      </optgroup>
      <transport method="put" trigger="hostname" path="cluster/esx/%(cluster)s/host/%(hostname)s" />
      <transport method="put" trigger="service" path="cluster/esx/%(cluster)s/service/%(service)s/%(instance)s" />
   </command>

   <command name="rebind_esx_cluster">
      Bind a vmhost or a service instance to the named cluster.

      If binding a vmhost that is already bound to a different cluster that
      binding will be removed.

      If binding a service instance for a service that is already bound to
      a different instance the old binding will be removed.
      <optgroup name="rebind_esx_cluster_opts" mandatory="True" fields="all">
         <option name="cluster" type="string">Cluster name</option>
	 <optgroup name="rebind_esx_cluster_object" mandatory="True" fields="any">
            <option name="hostname" type="string" conflicts="service">Server name</option>
	    <optgroup name="rebind_esx_cluster_service" fields="all">
               <option name="service" type="string" conflicts="hostname">Service name</option>
               <option name="instance" type="string">Service Instance</option>
            </optgroup>
         </optgroup>
      </optgroup>
      <transport method="post" trigger="hostname" path="cluster/esx/%(cluster)s/host/%(hostname)s" />
      <transport method="post" trigger="service" path="cluster/esx/%(cluster)s/service/%(service)s/%(instance)s" />
   </command>

   <command name="unbind_esx_cluster">
      Remove the binding of the vmhost or service instance from the named
      cluster.
      <optgroup name="unbind_esx_cluster_opts" mandatory="True" fields="all">
         <option name="cluster" type="string">Cluster name</option>
	 <optgroup name="unbind_esx_cluster_object" mandatory="True" fields="any">
            <option name="hostname" type="string" conflicts="service">Server name</option>
	    <optgroup name="unbind_esx_cluster_service" mandatory="False" fields="all">
               <option name="service" type="string" conflicts="hostname">Service name</option>
               <option name="instance" type="string">Service Instance</option>
            </optgroup>
         </optgroup>
      </optgroup>
      <transport method="delete" trigger="hostname" path="cluster/esx/%(cluster)s/host/%(hostname)s" />
      <transport method="delete" trigger="service" path="cluster/esx/%(cluster)s/service/%(service)s/%(instance)s" />
   </command>

   <command name="add_esx_cluster_aligned_service">
      Mark a service as aligned for ESX clusters.  All the members within an
      ESX cluster will be required to use the same service instance for the
      service.  Different ESX clusters can still have different service
      instances for the service.
      <optgroup name="add_aligned_service_opts" mandatory="True" fields="all">
         <option name="service" type="string" mandatory="True">service name</option>
      </optgroup>
      <optgroup name="optional_opts">
         <option name="comments" type="string">Comments</option>
      </optgroup>
      <transport method="put" path="service/%(service)s/aligned_for/cluster_type/esx" />
   </command>

   <command name="show_cluster_type">
      Show information about a cluster_type such as esx, including aligned
      services.
      <optgroup name="show_cluster_type_opts" mandatory="True" fields="any">
         <option name="cluster_type" type="string">cluster_type name</option>
         <option name="all" type="boolean" conflicts="cluster_type">Select all cluster types</option>
      </optgroup>
      <transport trigger="cluster_type" method="get" path="cluster_type/%(cluster_type)s" />
      <transport method="get" path="cluster_type" />
   </command>

   <command name="del_esx_cluster_aligned_service">
      Delete a service from the list of aligned services for the esx
      cluster_type.  Cluster members which are already bound to a
      service because it used to be aligned will be unmodified. If
      you wish to unbind those clients, they must be reconfigured.
      <optgroup name="del_aligned_service_opts" mandatory="True" fields="all">
         <option name="service" type="string" mandatory="True">service name</option>
      </optgroup>
      <transport method="delete" path="service/%(service)s/aligned_for/cluster_type/esx" />
   </command>

   <command name="add_dynamic_range">
      Add the allocated range of dynamic hosts.  The start and end
      IP addresses are inclusive.  The IPs must be on the same network.
      If there are any allocated systems already in the range the command
      will fail.

      For every IP address in the range a DNS entry will be generated of
      the form: prefix-X-X-X-X.subdomain where the X's are the components
      of the IP address.  The prefix defaults to the string 'dynamic'.
      <optgroup name="add_dynamic_range_opts" mandatory="True" fields="all">
         <option name="startip" type="string" mandatory="True">First IP address in the range to add</option>
         <option name="endip" type="string" mandatory="True">Last IP address in the range to add</option>
         <option name="dns_domain" type="string" mandatory="True">DNS domain to use for the generated names</option>
      </optgroup>
      <optgroup name="add_dynamic_range_opts" mandatory="False" fields="any">
         <option name="prefix" type="string">Prefix to use for generated names, defaults to 'dynamic'</option>
      </optgroup>
      <transport method="put" path="dynamic_range/%(startip)s/%(endip)s" />
   </command>

   <command name="del_dynamic_range">
      Delete the allocated range of dynamic hosts.  The start and end
      IP addresses are inclusive.  The IPs must be on the same network.
      If there are any allocated systems in the range that are not
      dynamic the command will fail.
      <optgroup name="del_dynamic_range_opts" mandatory="True" fields="all">
         <option name="startip" type="string" mandatory="True">First IP address in the range to delete</option>
         <option name="endip" type="string" mandatory="True">Last IP address in the range to delete</option>
      </optgroup>
      <transport method="delete" path="dynamic_range/%(startip)s/%(endip)s" />
   </command>

</commandline>
