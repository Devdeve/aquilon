#!/usr/bin/env python
# Copy AQDB to a different backend.
#
# The source backend is taken from $AQDCONF as usual, the destination backend
# is taken from command line.
#
# Warning: making a copy will cause the sequences in the source database to
# jump - there's no easy way around that.
#
# Examples:
#    ./aqdb_migrate sqlite:////path/aquilon.db
#    ./aqdb_migrate postgresql://<username>@/

import sys
import os

_DIR = os.path.dirname(os.path.realpath(__file__))
_LIBDIR = os.path.join(_DIR, "..", "lib", "python2.6")
if _LIBDIR not in sys.path:
    sys.path.insert(0, _LIBDIR)

from aquilon.aqdb import depends

import ms.version
ms.version.addpkg('psycopg2', '2.4.2-9.0.1', 'dev')

import argparse

from sqlalchemy import create_engine, Table
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.sql import text

from aquilon.aqdb.db_factory import DbFactory
from aquilon.aqdb.model import Base


def dummy_mapper(table):
    Base = declarative_base()

    class DummyMapper(Base):
        __table__ = table

    return DummyMapper


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='copy AQDB between backends')
    parser.add_argument('-v', '--verbose',
                        action='store_true',
                        dest='verbose',
                        help='show queries (metadata bind.echo = True)')
    parser.add_argument('dsn', metavar='DSN',
                        help='DSN of the target backend (driver://user[:password]@host[:port]/database)')
    opts = parser.parse_args()

    # Use aquilon.aqdb for connecting to the source backend
    db = DbFactory()
    if opts.verbose:
        db.engine.echo = True
    src_session = sessionmaker(bind=db.engine)()

    dest_engine = create_engine(opts.dsn, convert_unicode=True, echo=opts.verbose)
    dest_session = sessionmaker(bind=dest_engine)()

    if db.engine.dialect.supports_sequences and \
       dest_engine.dialect.supports_sequences:
        # The only operation on sequences that all DBs support is getting the
        # next value. Unfortunately that means we have to alter the state of the
        # source database here.
        for seq in Base.metadata._sequences.values():
            nextid = src_session.execute(seq)
            # Make sure the sequence is re-created with the right start index
            seq.drop(dest_engine, checkfirst=True)
            seq.start = nextid

    Base.metadata.create_all(dest_engine, checkfirst=True)

    for table in Base.metadata.sorted_tables:
        total = db.engine.execute(table.count()).scalar()
        print 'Processing %s (%d rows)' % (table, total),
        sys.stdout.flush()
        cnt = 0

        if dest_engine.dialect.name == 'postgresql':
            dest_session.execute(text('SET CONSTRAINTS ALL DEFERRED'))
        elif dest_engine.dialect.name == 'oracle':
            dest_session.execute(text('ALTER SESSION SET CONSTRAINTS = DEFERRED'))
        elif dest_engine.dialect.name == 'sqlite':
            # SQLite does not allow changing the deferred state at run-time, but
            # it does allow disabling foreign keys entirely
            dest_session.execute(text('PRAGMA foreign_keys = 0;'))

        columns = table.columns.keys()

        NewRecord = dummy_mapper(table)
        for record in db.engine.execute(table.select()):
            cnt = cnt + 1
            if not cnt % 15000:
                print "... %d" % cnt,
                sys.stdout.flush()

            data = dict(
                [(str(column), getattr(record, column)) for column in columns]
            )

            # insert() is faster, but using .merge() is restartable
            #dest_session.merge(NewRecord(**data))
            dest_session.execute(table.insert().values(**data))

        dest_session.commit()
        print
